<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C-迷路的指针 | Hu_SE</title><meta name="keywords" content="C"><meta name="author" content="Charm_Hu"><meta name="copyright" content="Charm_Hu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C-迷路的指针"><meta name="application-name" content="C-迷路的指针"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C-迷路的指针"><meta property="og:url" content="http://husj0711.top/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/index.html"><meta property="og:site_name" content="Hu_SE"><meta property="og:description" content="C语言基本数据类型 getchar()函数 只能从键盘缓冲区接收字符，一次只能接收一个字符。如果之前有scanf(&amp;quot;%c&amp;quot;,&amp;amp;str);类似语句，回车键\n也被会当作一个字符留在键盘缓冲区。如果不是char类型倒不要紧。 如果之前没有用scanf()接收过字符,那么使用g"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://ooo.0x0.ooo/2024/01/04/OZab3F.jpg"><meta property="article:author" content="Charm_Hu"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ooo.0x0.ooo/2024/01/04/OZab3F.jpg"><meta name="description" content="C语言基本数据类型 getchar()函数 只能从键盘缓冲区接收字符，一次只能接收一个字符。如果之前有scanf(&amp;quot;%c&amp;quot;,&amp;amp;str);类似语句，回车键\n也被会当作一个字符留在键盘缓冲区。如果不是char类型倒不要紧。 如果之前没有用scanf()接收过字符,那么使用g"><link rel="shortcut icon" href="/%E6%9D%B0%E5%B0%BC%E9%BE%9F.ico"><link rel="canonical" href="http://husj0711.top/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"网页崩溃啦！┭┮﹏┭┮","backTitle":"噫O(∩_∩)O又好了！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Charm_Hu","link":"链接: ","source":"来源: Hu_SE","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hu_SE',
  title: 'C-迷路的指针',
  postAI: '',
  pageFillDescription: 'C语言, 基本数据类型, 选择结构程序设计, 循环结构程序设计, 数组, 数组定义及初始化, 字符串输入与输出, 字符串处理函数, 指针, 指针与指针变量, 一维数组与指针的关系, 指针与数组的区别, 指针数组和数组指针, 指针与二维数组, void指针与NULL指针, 指向指针的指针, 指向指针的指针与二维数组, 常量和指针, 函数, 函数初体验, 参数和指针, 指针函数与函数指针, 局部变量与全局变量, 作用域与链接属性, 作用域, 链接属性, 生存期与存储类型, 生存期, 存储类型, 递归, 动态内存管理, malloc函数, free函数, 内存泄漏, 申请任意尺寸的内存空间, calloc函数, realloc函数, 文件操作, 顺序读写文件语言基本数据类型函数只能从键盘缓冲区接收字符一次只能接收一个字符如果之前有类似语句回车键也被会当作一个字符留在键盘缓冲区如果不是类型倒不要紧如果之前没有用接收过字符那么使用函数时需要先键入字符按键后键入的字符串进入缓冲区然后会从中取一个字符按输入的顺序以后每次调用都会从缓冲区接收一个字符直至缓冲区字符用完再重复以上步骤函数的返回值也不是字符而是一个整型读取成功时就返回该字符的值失败时就返回一个典型例题加密电文所有大小写英文字母码循环其余字符不变函数函数返回值是是成功读取并赋值的参数的数量函数返回值分为种返回正整数表示正确输入参数的个数返回整数表示用户的输入不匹配无法正确输入任何值返回表示输入流已经结束在下用户按下会看到一个字符再按下回车可能需要重复多次就表示输入结束下使用表示输入结束参考如下例题计算输入整数满足正确算式的数量上述例题的两种解法链接中已给出一种下给出另一种判断条件是不为遇到换行符即表示输入结束也是从键盘缓冲区得到输入一般来说遇到换行符就表示输入项结束了但在上述例子计算输入整数满足正确算式的数量中由于一次性需要接收三个参数此时换行符就不起作用了需要手动敲再按回车上就表示输入项的结束具体可参考详解输入输出流结束标志和逗号表达式逗号表达式一般形式为逗号表达式从左到右依次求值每个表达式的值被忽略除了最后一个表达式逗号表达式的值就是最后一个表达式的值运算符优先级及结合性结论先计算优先级大的相同优先级再根据结合性计算观察如下代码结果是于是疑问出现了自增运算符优先级不是大于乘吗不是先自增再乘嘛这样其实程序确实先进行自增运算符但和返回的结果是不同的然后再赋值给特别是它的返回值就是而的返回值是所以造成一种假象以为先进行了乘法运算小试牛刀关于为啥总是得到因为的结合性是自左向右故先会计算此时值是故返回值是再计算返回值是由此可以看出学了之后再学感觉步骤很啰嗦但正是因为步骤啰嗦分类齐全条理清晰故速度很快选择结构程序设计注意按顺序判断只要其中一个条件为真剩下的就不会执行如果没有大括号就遵循就近原则所以写的时候尽量带上大括号例如最后结果什么也不会输出因为其相当于选择语句注意表达式的值必须为整型数据当然包括字符型而必须是常量或者常量表达式表达式表达式必须加上否则后续会一直执行直到或者全部读完表达式表达式的值为时就执行对应语句也可以写成这样表达式表达式表达式可以不用反正都结束了语言中唯一一个三目运算符条件运算符对应表达式就是条件表达式条件语句等价于循环结构程序设计循环表达式为真进入循环直至表达式为假或者跳出循环表达式语句循环特别注意后面还有个分号语句表达式循环其中表达式和可以为逗号表达式表达式是判断条件为真的话继续表达式表达式表达式语句等价于表达式表达式语句表达式数组数组定义及初始化一维数组定义二维数组同理类型符数组名常量表达式特别注意是常量表达式不能是变量但是推出了变长数组它允许在运行时动态地定义数组的长度但一旦定义在其生命周期内大小不可改变例如其他操作同时值得注意的是不允许在定义的时候初始化例如编译器会报错二维数组是一维数组线性拓展得到的也是以线性的方式存储的数组名的值数组第一个元素的地址相当于是一个常量是不能被赋值的因此下列数组初始化是错误的字符串输入与输出如何直接输出字符串或者输入字符串输出是已定义的字符串数组特别注意不能输出多个字符串而可以输入由于的值就是数组第一个元素的地址故不需要取值符同时输入的字符串大小应不大于定义的字符数组的大小同理一次只能接收一个字符串数组字符串处理函数函数名称作用返回值输出单个字符串输入单个字符串测量字符串的长度返回字符串的长度不包括测量字符串的内存大小返回字符串的内存大小注意如果字符串没规定大小如则返回值包括如果规定大小了则返回的值该大小所占字节补充测量其他类型数组的内存大小返回其他类型数组的内存大小此时并没有的烦恼了将字符串接到字符串后面返回的是字符串的地址将字符串包括复制到字符串中返回的是字符串的地址将字符串前个字符复制到字符串中返回的是字符串的地址将字符串中大小写字母变成小写字母不返回任何值对于字符串是原位修改将字符串中大小写字母变成大写字母不返回任何值对于字符串是原位修改依次比较和中字符的大小按照码比较则返回则返回一个正整数则返回一个负整数指针指针与指针变量指针变量也是一个变量占用的字节大小取决于其存储的内存地址的大小而常说的指针应该是指针变量其值是内存地址指针需要说明的是后续所讲指针多指指针变量例如指向变量完整的说法是的值是变量的地址前提重点可以认为声明指针变量为取地址运算符用是因为指针变量所储存的内存地址所对应的数据类型是打印内存地址打印变量的值这里是取值运算符也即下面以小甲鱼的一道课后习题来介绍请问下边代码执行后打印机的结果是什么另外是左值还是右值打印结果是第一个问题定义指针变量的时候存放的是变量的地址在此之后即对变量的间接访问通过地址访问变量所以相当于也就是说通过指针对一个变量间接访问你可以理解为把它作为那个变量本身使唤即第二个问题指针变量既是左值也是右值此外关于取址符还有个疑问一般来说取址符作用对象是左值而数组名不是左值为啥取址符还可以作用于数组名其实左值下面有个子集可修改的左值位于等式左边必须要求可修改的左值由此可见之前一直存在认知误区其实数组名是左值只是不可修改罢了于是有以下结论取址符作用于左值数组名是左值不可修改的左值故可将取址符作用于数组名参考数组和指针的区别一维数组与指针的关系不特别说明数组均指一维数组数组名指针变量数组名储藏着数组第一个元素的地址对于字符数据类型可以直接用指针创建数组下面代码演示此处相当于是然而对于等类型通过指针创建是行不通究其原因是因为字符数组就是第一个字符的地址指针变量且字符数组名和其他数组名一样也是指针变量指向数组第一个元素上述和都可以当作指针变量会输出通过指针访问数组结果就是这就是通过指针间接访问数组的办法区别于下标直接访问法此处要注意的是只有当指针指向数组元素时指针算术运算才有意义否则就会给未用地址乱赋值就会报错既然数组名也是一个指针变量那么同理也用数组名进行访问如下这个为后续指针数组做下铺垫例如这里是一个指针变量存着数组的地址就是数组也就代表着数组第一个元素的地址从而有同时又可以发现指针所指向的数据类型决定指针的跨度指针与数组的区别指针变量是左值可以修改的而数组名是地址常量不可以修改故不是左值代码如下此处必须用指针变量不能用数组名这里是啥呢由于增运算符变量的优先级大于取值运算符故先进行再取值相当于同时还需注意自增运算符在变量后面故取值符取用的是未自增前的值总共有个数字小甲鱼作业第题请问是否可以写成语言中被解释为故两者等价指针数组和数组指针指针数组是指数组元素全为指针的数组数组指针是一个指针它指向的是一个数组区分下列哪个是指针数组哪个是数组指针就相当于就是数组地址区别于数组首地址后面会讲到优先级大于虽然和优先级一样但结合性是从左到右故第一个是指针数组第二个是数组指针指针数组的一个用途由于指针数组存放的都是指针而数组名就是指针变量让编程改变世界一切皆有可能是通过字符串首地址输出字符串关于数组指针还有一个坑数组指针指向的是一个数组而我们之前常用此处是一个已定义的整型数组来将指针指向数组但实际上指针只是指向了数组第一个元素的地址现在我们要想数组指针指向整个数组需使用这里相当于将整个数组看作一个整体来看待的必须清楚的是数组第一个元素的地址跟整个数组的地址是相同的举例如下输出也可以因为把数组当作整体给出地址还是数组首地址但编译器会提醒是一个指向数组并非指向数组第一个元素的指针就是取出该指针对应的内容也就是数组即而又是数组第一个元素的地址可以当作指针并进行指针运算注意此时数组的第一个元素有点嵌套指针的意味了于是上述输出也可写成小甲鱼课后作业定义指向包含个指针的数组的指针也就是说这个数组的类型是字符指针类型故定义相同类型的数组指针此处实际上是指向包含个指针的数组最好写成指针与二维数组观察下述代码二维数组输出结果是由此得出二维数组的数组名指向包含个元素的数组也就是第一行元素所构成的数组二维数组名实际上就是数组指针同时也可明白则指向第二行构成的数组即此处的相当于前述的二维数组名也可赋值给数组指针指向第一行元素构成的数组指向第二行元素构成的数组输出第一行元素构成的数组的地址输出第一行元素构成的数组的地址输出第一行元素构成的数组的地址注意并非数组的第一个元素尽管两者数值上相等输出第一行元素构成的数组的第一个元素的地址是第一行元素构成的数组的地址则是第二行元素构成的数组的地址因为二维数组在内存中也是线性存储的表示指针往后移个字节也就是第二行元素构成的数组的地址即指向第二行元素构成的数组指针与指针指针我们把它称之为通用指针就是可以指向任意类型的数据也就是说任何类型的指针都可以赋值给指针于是又引出几个问题指针如何取值编译器怎么知道所以强制转换符强制转换类型又出现了对于指针移动多少个字节由于编译器不知道其指向的数据类型故只移动一个字节指针即空指针不指向任何一个地址空指针的宏定义定义空指针解引用取值的话程序会报错也可以写成还未初始化称为野指针注意是而不是在表中用于指针和对象表示控制指向一个不被使用的地址表示字符串的结尾小甲鱼指针和二维数组第题出现了强制类型转换符具体代码如下等号右边强制将这个一位数组重新划分成的二维数组等于二维数组这与前面第条所说二维数组名就是数组指针相呼应小甲鱼的答案有点问题并不是指向二维数组就是二维数组名指向二维数组第一行元素构成的数组指向指针的指针此即指向指针的指针验证是否指向指针那指向指针的指针有啥用呢观察如下代码带你学带你飞与指针由此可以看出指向指针的指针至少有以下两个好处避免重复分配内存只需对一处进行修改指向指针的指针与二维数组观察如下代码对应着对应由于是一个指针故就是指针移动个数据类型所占的字节例如则就是第一行元素构成数组的地址如果再取值由于找不到对应的内容因为无论是整个数组地址还是数组第一个元素的地址数值上都等于数组第一个元素的地址且二维数组的行并不一定在内存中是连续存储的因此使用错误的指针类型可能导致对内存的错误访问从而触发段错误可行因为本身可看作数组指针就是移向下一行因此要想正确输出需将上述代码改为如下利用数组指针这里值得注意的是因为实际上是第一行元素的构成的数组的地址中必须要和该数组元素个数相等指向一个个元素的数组则移动个字节而如果是此时是指向第一行元素的构成的数组的第一个元素此时移动个字节由上可见正如第条最后所说指针所指向的数据类型决定指针的跨度小试牛刀站这一节课有弹幕指出可以写成这个其实相当于定义了一个指向二维数组的指针代码可修改如下由于指向整个二维数组故就是二维数组指向二维数组第一行元素构成的数组这样也就弱化为指向数组的指针了同前述第节常量和指针常量常变量这样使得只能读不能修改相当于常量但不是常量定义指向常量的指针区别于后续所讲常量指针定义指向常量的指针如果尝试修改指向常量的指针指向的值则会发生错误如果尝试修改指向常量的指针的值这是允许的相当于该指针不指向常量编译通过此时如果改变指向的值则报错但是我们如果修改的值编译成功指向常量的指针总结指针可以修改为指向不同的常量指针可以修改为指向不同的变量可以通过解引用来读取指针指向的数据不可以通过解引用修改指针指向的数据那什么是常量指针呢定义指向非常量的常量指针特性指针本身值不可改变指向的值可修改典型例子就是数组名定义指向非常量的常量指针修改指向的值编译成功修改本身值报错如果定义一个指向常量的常量指针如果此时既修改指针的值又修改指针所指向的值则会报两个错可以看出其特点指针本身值不可改变指向的值也不可修改但有趣的一点是如果你定义了指向常量的常量指针但接受的地址不是常量还是可以通过改变该非常量来修改指针所指向的值的如下输出又进一步引出指向指向常量的常量指针的指针看到名字别害怕去掉定语也即指向指针的指针要记住一般来说要指向常量指针自己也必须是指向常量的指针但如果自己不是指向常量的常量指针也可以的不过会有后面详细介绍了的约束对象理解将会更加深刻代码如下定义指向常量指针的指针上行代码也可以写成但不推荐验证指向验证验证小甲鱼常量和指针关于的约束对象请问在下边声明中限制的是还是答第一个限制即指针的两次解引用可以理解为但不是因为如果是那么还是可以修改的而则是不可以的第二个限制同上述理记住一点永远限制紧随着它的标识符那么如果想要使用同时限制和应该怎么做或者因为等价于但一般为了可读性就不写成但更能体现这句话永远限制紧随着它的标识符于是又有人问了限制了啥其实只限制了重点限制了谁谁就变可读了不能修改也就不是可修改的左值了函数函数初体验语言程序编译的时候是从上至下执行的时候是从函数开始的函数不返回任何值因此不需要加养成好习惯要使用某个函数先进行声明千万别丢了分号函数声明时既可带上参数名也可不带例如如果定义一个与标准库函数重名的函数会怎样重新定义的同名函数会覆盖标准库函数前提是两者的声明一致包括返回值和参数类型个数一致参数和指针传值和传址观察下列两个代码传值交换前交换后结果输出交换前交换后传址交换前交换后结果输出交换前交换后为啥结果会不同呢因为函数会给单独在内存中找两段储存空间可理解为局部变量存放传进来的值对原来地址上的值无影响如果传给函数的本就是地址则函数内部调用时就是直接对原来地址上的值进行操作传数组由于传递数组本质是传递数组第一个元素地址此处可以不写数组元素个数由于传递的是一个地址也就是指针取决于操作系统我的操作系统是位故返回可变参数首先需要调用头文件具体实现原理可见可变参数详解常见用法如下以固定参数的地址为起点依次确定各变参的内存起始地址定义类型的指针用于存储参数地址初始化指针使其指向第一个可变参数该宏第二个参数是变参列表的前一个参数即最后一个固定参数该宏返回变参列表中的当前变参值并使指向列表中的下个变参该宏第二个参数是要返回的当前变参类型若函数有多个可变参数则依次调用宏获取各个变参将指针置为无效结束变参的获取举个栗子打印固定参数堆栈上方一个内容垃圾值打印固定参数堆栈上方一个内容原理图如下所示小试牛刀尝试实现函数勇攀高峰尝试自己模拟实现格式化输出的基本功能基本要求如下输出第一个参数中除了格式化占位符外的所有字符实现的格式化输出实现的格式化输出实现的格式化输出实现函数返回打印了多少字符全程仅能使用唯一一个标准库函数共打印了个字符包含共打印了个字符包含指针函数与函数指针指针函数定义使用指针变量作为函数的返回值的函数就是指针函数写成可能更好理解但遵循一般习惯就这样吧字符指针需要特别注意的是不要返回局部变量的指针举例如下不要写成下面这样因为函数一结束所有变量值会被清理掉虽然返回了变量的地址但该地址上啥值也没有请输入要查询的字符可能又有人问了为啥可以直接返回字符串哪些呢参考回答函数指针定义指向函数的指针定义函数指针此处第一个取决于所指向的函数的返回值第二个取决于函数的输入参数就跟函数定义时相同即可初始化函数指针也可以写成但没必要因为一般来说函数编译后函数名就是函数的地址在主函数中通过函数指针调用函数其实也可以写成但为了与函数混淆还是写成上面那种形式比较好需要注意的就是函数编译后函数名就是函数指针函数指针作为参数举个栗子将函数指针作为参数函数指针作为返回值接着上节举个栗子定义一个参数为类型返回值为函数指针的函数函数指针作为参数函数指针作为返回值请输入计算表达式从上面我们可以发现定义返回值类型为函数指针参数类型为字符的函数且所返回的函数指针指向的函数接收两个类型参数且返回值为类型的操作为函数拓展函数函数详解传送门举个栗子将整数以进制数的形式写入字符数组打印字符串输出结果为从而印证上述说法局部变量与全局变量局部变量局部变量是指在特定范围内声明和使用的变量这个特定的范围通常是在一个函数或者一个代码块内部特定范围中一个函数的情况很常见对于代码块内部下面举一例进行说明在循环内部的只作用于该循环且循环内部调用的只能是这里定义的在循环外面调用的就是这里定义的如下图所示不过要注意的是才允许上述在语句中定义变量因为允许在使用时才定义变量而不是一开始在最上面定义变量全局变量在函数里面定义的我们叫局部变量在函数外部定义的我们叫外部变量也叫做全局变量注意如果不对全局变量进行初始化那么它会自动初始化为如果在函数的内部存在一个与全局变量同名的局部变量编译器并不会报错而是在函数中屏蔽全局变量也就是说在这个函数中全局变量不起作用举例如下运行结果一般来说编译器不允许先使用变量再定义否则会报错但是如果我们使用关键字则是可以的该关键字的功能就是告诉编译器我是定义了这个变量的只不过在后面作用域与链接属性作用域作用域包括以下几种类型代码块作用域文件作用域原型作用域函数作用域代码块作用域文件作用域原型作用域函数作用域在代码块中定义的变量具有代码块作用域作用范围是从变量定义的位置开始到标志该代码块结束的右大括号处另外尽管函数的形式参数不在大括号内定义但其同样具有代码块作用域隶属于包含函数体的代码块运行结果任何在代码块之外声明的标识符都具有文件作用域作用范围是从它们声明位置开始到文件的结尾处结束另外函数名也具有文件作用域因为函数名本身也在代码块之外定义了一定是声明了典型的就是全局变量的定义故作用范围是从定义的位置开始到文件结尾处结束函数声明全局变量声明当然也可以直接定义例如在函数前面写运行结果是很显然如果没有声明和那么编译器也不知道后面会有和就报个错先进一步可以看出具有文件作用域的标识符包括函数名和全局变量原型作用域只适用于那些在函数原型中声明的参数名我们知道函数在声明的时候可以不写参数的名字但参数类型是必须要写上的其实尝试一下还可以发现函数原型的参数名还可以随便写一个名字不必与函数定义时的形式参数相匹配当然这样做毫无意义之所以允许这么做是因为原型作用域起了作用函数原型亦称为函数声明函数定义函数作用域只适用于语句标签而语句标签用于语句使用规则一个函数的所有语句标签必须唯一语句的作用域是一个函数的大小而不是一个代码块链接属性啥是链接可能刚开始比较疑惑那就看看语言源代码是如何编程可执行文件的吧传送门链接属性分类外部属性多个文件中声明的同名标识符表示同一个实体内部属性单个文件中声明的同名标识符表示同一个实体空链接属性声明的同名标识符中被当作不同独立的实体比如函数的局部变量因为它们被当作独立不同的实体所以不同函数间同名的局部变量并不会发生冲突特点只有具备文件作用域的标识符才能拥有或的链接属性其他作用域的标识符都是属性默认情况下具备文件作用域的标识符拥有属性使用关键字对链接属性的修改使用关键字修改链接属性只对具有文件作用域的标识符生效对于拥有其他作用域的标识符是另一种功能当然只是对链接属性进行了修改作用域还是没变链接属性只能修改一次也就是说一旦将标识符的链接属性变为就无法再变回了这样做的好处就是保护全局变量以免在其他文件中被修改本节作用域与链接属性是从空间角度分析的下面将从时间角度作为切入点生存期与存储类型生存期语言拥有两种生存期静态存储期自动存储期静态存储期自动存储期具有文件作用域的变量属于静态存储期函数也属于静态存储期属于静态存储期的变量在程序执行期间将一直占据存储空间直到程序关闭才释放具有代码块作用域的变量一般情况下属于自动存储期属于自动存储期的变量在代码块结束时将自动释放存储空间存储类型语言提供了五种不同的存储类型静态存储变量和自动变量寄存器变量静态局部变量和默认适用对象函数中的形参局部变量及复合语句中定义的局部变量等特性拥有代码块作用域自动存储期和空连接属性在代码块中声明的变量默认的存储类型就是不过可以省略平常我们写的时候就省略了不过当强调局部变量屏蔽全局变量这一做法时可以在局部变量前加上声明特性代码块作用域自动存储期和空链接属性不能通过取址运算符获得该变量的地址将一个变量声明为寄存器变量那么该变量就有可能被存放于位于的寄存器为啥说有可能呢因为的寄存器空间十分有限所以编译器并不会让所有声明为的变量都放到寄存器中事实上有可能所有的关键字都被忽略因为编译器有自己的一套优化方法会权衡哪些才是最常用的变量在编译器看来它比你更了解程序而那些被忽略的变量它们会变成普通的自动变量首先可能有人会好奇为啥会叫静态局部变量呢这就对了因为作用于全局变量时是修改其链接属性那么作用于局部变量会发生什么奇妙的事情呢作用于局部变量会使局部变量的生存期由自动存储期变为静态储存期由此可得其特性特性空链接属性代码块作用域静态存储期举例如下输出结果为此处所指不同于前述静态局部变量所讲的这里所讲和的作用域是文件作用域关键字使得默认具有链接属性的标识符变成链接属性而关键字告诉编译器这个变量或函数在别的地方已经定义过了先去别的地方找找不要急着报错该类型将在结构体章节详细阐述递归切记递归一定要有结束条件基操实现阶乘小试牛刀汉诺塔快速排序实现如下表示的意义为从移到位置借助特别要注意比较完之后要向中间靠拢否则遇见的情况就会陷入死循环最后和一定是相邻的因为走过的必定是满足也就不可能满足了同理走过的必定不可能满足故最后会相邻且动态内存管理在之前所学中变量一经定义其内存大小就不能再更改了那么有什么办法能让语言更灵活地管理内存资源呢答案是有的需要借助几个库函数这几个库函数在这个头文件中函数函数原型函数向系统申请分配个字节的内存空间并返回一个指向这块空间的指针不过要注意申请的这块空间并没有被清理初始化为所以它上面的数据是随机的就与局部变量一样如果函数调用成功会返回一个指向申请的内存空间的指针由于返回类型是指针所以它可以被转换成任何类型的数据如果函数调用失败返回值是另外如果参数设置为返回值也可能是但这并不意味着函数调用失败函数函数原型由于函数申请的空间位于内存的堆上如果不主动释放它那么它会一直存在直到程序结束所以以后写程序和要成对故上面程序应该为释放内存内存泄漏内存泄漏指的是在程序运行过程中动态分配的内存空间没有被正确释放的情况导致内存泄漏主要有以下两种情况隐式内存泄漏即用完内存块没有及时使用函数释放掉丢失内存地址丢失内存地址就是说把原本指向动态申请的内存地址的指针指向别的地方了例如丢失内存地址申请任意尺寸的内存空间不仅可以申请基本类型数据的空间还可以申请一块任意的内存空间对于后者由于申请得到的空间是连续的通常采用数组来进行索引请输入一个整数由于并不会初始化申请的内存空间所以需要自己进行初始化当然可以写个循环来做这件事但不建议这么做标准库提供了更加高效的函数以开头的函数被编入字符串标准库函数的声明包含在这个头文件中函数传送门除了函数之外类似的还有等等可见小甲鱼函数快查传送门细心的同学可能发现了这样每次写完还要再写略显繁琐于是语言提供了函数一步实现上述功能函数函数原型函数在内存中动态地申请个长度为的连续内存空间即申请的总空间尺寸为这些内存空间全部被初始化为如果函数调用成功会返回一个指向申请的内存空间的指针由于返回类型是指针所以它可以被转换成任何类型的数据如果函数调用失败返回值是如果或参数设置为返回值也可能是但这并不意味着函数调用失败函数与函数的一个重要区别是函数在申请完内存后自动初始化该内存空间为而函数不进行初始化操作里边数据是随机的因此下面两种写法是等价的函数在现实操作中我们会经常碰到内存空间不足的问题需要扩展此时可以借和进行扩充请输入一个整数这样的操作比较繁琐还好语言有相应的库函数没错就是函数原型不过需要注意以下几点函数将指向的内存空间大小修改为字节如果新分配的内存空间比原来的大则旧内存块的数据不会发生改变如果新分配的内存空间比原来的小则可能导致数据丢失请慎用该函数将移动内存空间的数据并返回新的指针如果参数为那么调用该函数就相当于调用如果参数为并且参数不为那么调用该函数就相当于调用除非参数为否则的值必须由先前调用或函数返回编写一个程序不断地接收用户输入的整数直到用户输入表示输入结束将所有数据打印出来此处必须初始化为因为参数中要求了如前述注意事项最后一点无论是还是函数都需要搭配函数释放内存文件操作顺序读写文件本节主要练习那些文件操作函数见传送门语言函数索引常用的例如区别于看着很像区别于这一节还有几个比较有趣的拓展阅读如何理解万物皆文件文本流与二进制流的区别',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-17 20:10:46',
  postMainColor: '#87CEEB',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://ooo.0x0.ooo/2024/01/02/OKuyvU.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.husj0711.top/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Hu_SE</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9246893035&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/Kriging%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">Kriging模型<sup>1</sup></a><a href="/tags/%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95/" style="font-size: 1.05rem;">中心差分法<sup>1</sup></a><a href="/tags/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">力学基础与专业基础<sup>1</sup></a><a href="/tags/%E5%8D%95%E8%AF%8D%E6%8B%BC%E8%AF%BB/" style="font-size: 1.05rem;">单词拼读<sup>1</sup></a><a href="/tags/%E6%8C%AF%E5%9E%8B%E5%88%86%E8%A7%A3%E5%8F%8D%E5%BA%94%E8%B0%B1%E6%B3%95/" style="font-size: 1.05rem;">振型分解反应谱法<sup>1</sup></a><a href="/tags/%E6%A3%80%E7%B4%A2%E8%B5%84%E6%96%99/" style="font-size: 1.05rem;">检索资料<sup>1</sup></a><a href="/tags/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/" style="font-size: 1.05rem;">毕业论文<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 1.05rem;">生活<sup>1</sup></a><a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">神经网络<sup>1</sup></a><a href="/tags/%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/" style="font-size: 1.05rem;">科研绘图<sup>1</sup></a><a href="/tags/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">结构设计杂谈<sup>1</sup></a><a href="/tags/%E9%9F%B3%E6%A0%87/" style="font-size: 1.05rem;">音标<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" itemprop="url">编程学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C-迷路的指针</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-13T06:23:57.426Z" title="发表于 2023-11-13 14:23:57">2023-11-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-03-17T12:10:46.644Z" title="更新于 2024-03-17 20:10:46">2024-03-17</time></span></div><div class="meta-secondline"></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://ooo.0x0.ooo/2024/01/04/OZab3F.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://husj0711.top/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/"><header><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" itemprop="url">编程学习</a><a href="/tags/C/" tabindex="-1" itemprop="url">C</a><h1 id="CrawlerTitle" itemprop="name headline">C-迷路的指针</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Charm_Hu</span><time itemprop="dateCreated datePublished" datetime="2023-11-13T06:23:57.426Z" title="发表于 2023-11-13 14:23:57">2023-11-13</time><time itemprop="dateCreated datePublished" datetime="2024-03-17T12:10:46.644Z" title="更新于 2024-03-17 20:10:46">2024-03-17</time></header><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol>
<li>getchar()函数<ol>
<li><strong>只能从键盘缓冲区接收字符，一次只能接收一个字符</strong>。如果之前有<code>scanf(&quot;%c&quot;,&amp;str);</code>类似语句，回车键<code>\n</code>也被会当作一个字符留在键盘缓冲区。如果不是char类型倒不要紧。</li>
<li>如果之前没有用scanf()接收过字符,那么使用getchar()函数时，需要先键入字符，<strong>按enter键后</strong>，键入的字符(串)进入缓冲区，然后getchar会从中取一个字符(按输入的顺序)，以后每次调用getchar()都会从缓冲区接收一个字符，直至缓冲区字符用完，再重复以上步骤。</li>
<li>getchar()函数的返回值也不是字符而是一个整型.(读取成功时就返回该字符的ASCⅡ值，失败时就返回一个-1。)</li>
<li>典型例题：加密电文，所有大小写英文字母＋4(ASCII码) 循环，其余字符不变。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; (str=getchar()) != <span class="string">&#x27;\n&#x27;</span> ; )&#123;</span><br><span class="line">        <span class="keyword">if</span> (str&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str &gt;= <span class="string">&#x27;A&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;A&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>scanf()函数</p>
<ol>
<li><p>scanf()函数返回值是是成功读取并赋值的参数的数量。<br>scanf()函数返回值分为3种：<br>(1). 返回正整数。表示正确输入参数的个数。<br>(2). 返回整数0。表示用户的输入不匹配，无法正确输入任何值。<br>(3). 返回-1。表示输入流已经结束。在Windows下，用户按下CTRL+Z（会看到一个^Z字符）再按下回车（可能需要重复多次），就表示输入结束；Linux/Unix下使用CTRL+D表示输入结束。</p>
<p>参考如下例题：<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>.<br>上述例题的两种解法：(链接中已给出一种，下给出另一种)    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j,d[<span class="number">3</span>];</span><br><span class="line">   <span class="type">int</span> judge = <span class="number">1</span>,count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; judge;)&#123; <span class="comment">//判断条件是judge不为0.</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[j]);</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">               judge = <span class="number">0</span>; <span class="comment">//遇到换行符即表示输入结束。</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (j == <span class="number">3</span> &amp;&amp; (d[<span class="number">0</span>] + d[<span class="number">1</span>] == d[<span class="number">2</span>]))&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>scanf()也是从键盘缓冲区得到输入，一般来说，遇到换行符<code>\n</code>就表示输入项结束了，但在上述例子<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>中，scanf由于一次性需要接收三个参数，此时换行符<code>\n</code>就不起作用了，需要手动敲<code>ctrl + z</code>再按回车。<strong>windows上，<code>ctrl + z</code>就表示输入项的结束</strong>。具体可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/i6223671/article/details/89041492">详解输入输出流结束标志ctrl+z和EOF</a>.</li>
</ol>
</li>
<li>逗号表达式<br>逗号表达式一般形式为: <code>expr1, expr2, expr3,...,exprn</code>.<br>逗号表达式从左到右依次求值，每个表达式的值被忽略，除了最后一个表达式。逗号表达式的值就是最后一个表达式的值。   </li>
<li><p>运算符优先级及结合性<br>结论：<strong>先计算优先级大的，相同优先级再根据结合性计算</strong>。<br><div align="center"><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/运算符优先级及结合性.jpg" width="90%"></div><br>观察如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">5</span>, y;</span><br><span class="line"></span><br><span class="line">   y = <span class="number">2</span> * x++;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;x = %d&quot;</span>,x);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;y = %d&quot;</span>,y);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是:</p>
<blockquote>
<p>x = 6; y = 10;</p>
</blockquote>
<p>于是疑问出现了，自增运算符<code>++</code>优先级不是大于乘<code>*</code>吗？不是先自增再乘嘛，这样<code>y = 2*6 = 12</code>.<br>其实：程序确实先进行自增运算符，但<code>++x和x++</code>返回的结果是不同的，然后再赋值给y。<strong>特别是x++，它的返回值就是x，而++x的返回值是x + 1</strong>, 所以造成一种假象，以为先进行了乘法运算。<br>小试牛刀：  </p>
<blockquote>
<p>关于<code>str = &#39;!&#39;; 48 &lt;= str &lt;= 57</code>为啥总是得到1？</p>
</blockquote>
<p>因为<code>&lt;=</code>的结合性是自左向右，故先会计算<code>48 &lt;= str</code>,此时str = ‘!’,ASCII值是33，故返回值是0.再计算<code>0 &lt;= 57</code>,返回值是1.由此可以看出学了python之后，再学C感觉步骤很啰嗦。但正是因为步骤啰嗦（分类齐全，条理清晰），故C速度很快。</p>
</li>
</ol>
<h2 id="选择结构程序设计"><a href="#选择结构程序设计" class="headerlink" title="选择结构程序设计"></a>选择结构程序设计</h2><ol>
<li>注意<code>if - else if - else</code>，按顺序判断，只要其中一个条件为真，剩下的就不会执行！<br>如果<strong>没有大括号就遵循就近原则</strong>，所以写的时候尽量带上大括号。例如:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">      <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
最后结果什么也不会输出！因为其相当于<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>switch</code>选择语句：注意表达式A的值必须为整型数据（当然包括字符型），而a、b…必须是常量或者常量表达式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式A) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> a:  表达式<span class="number">1</span>  ; <span class="keyword">break</span>;  <span class="comment">// 必须加上break，否则后续case会一直执行，直到break或者全部读完。</span></span><br><span class="line">   <span class="keyword">case</span> b:  表达式<span class="number">2</span>  ; <span class="keyword">break</span>;  <span class="comment">// 表达式A的值为a\b..时，就执行对应语句。</span></span><br><span class="line">   <span class="keyword">case</span> c: &#123; <span class="comment">// 也可以写成这样。</span></span><br><span class="line">     表达式<span class="number">1</span>;</span><br><span class="line">     表达式<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">default</span>:  表达式n ; <span class="keyword">break</span>;  <span class="comment">// 可以不用break,反正都结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C语言中唯一一个三目运算符：条件运算符(<code>? :</code>)，对应表达式就是条件表达式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b ? a:b</span><br><span class="line"><span class="comment">//条件语句</span></span><br><span class="line">c = a &gt; b ? a:b ;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">   c = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   c = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环结构程序设计"><a href="#循环结构程序设计" class="headerlink" title="循环结构程序设计"></a>循环结构程序设计</h2></li>
<li><code>while</code>循环：表达式为真，进入循环，直至表达式为假或者<code>break;</code>跳出循环.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>do while</code>循环：特别注意while后面还有个分号<code>;</code>.  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>；</span><br><span class="line">   ...</span><br><span class="line">&#125; <span class="keyword">while</span> (表达式) ;  </span><br></pre></td></tr></table></figure></li>
<li><code>for</code>循环:其中表达式1和3可以为<strong>逗号表达式</strong>，表达式2是判断条件，为真的话继续。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) </span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line">表达式<span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">   表达式<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组定义及初始化"><a href="#数组定义及初始化" class="headerlink" title="数组定义及初始化"></a>数组定义及初始化</h3><p>一维数组定义：(二维数组同理)</p>
<blockquote>
<p>类型符  数组名[常量表达式]</p>
</blockquote>
<p>特别注意是<strong>常量表达式</strong>，不能是<strong>变量</strong>。<br>但是！C99推出了<strong>变长数组</strong>(Variable Length Array，VLA),它允许在运行时动态地定义数组的长度，但一旦定义，在其生命周期内大小不可改变。<br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of rows: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;rows);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of columns: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cols);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> matrix[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同时，值得注意的是，<strong>VLA不允许在定义的时候初始化</strong>！<br>例如<code>int matrix[rows][cols] = &#123;0&#125;;</code>，编译器会报错。</p>
<hr>
<p>二维数组是一维数组线性拓展得到的，也是以线性的方式存储的。<br>数组名的值数组第一个元素的地址，相当于是一个常量，是不能被赋值的。因此下列数组初始化是错误的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串输入与输出"><a href="#字符串输入与输出" class="headerlink" title="字符串输入与输出"></a>字符串输入与输出</h3><p>   如何直接输出字符串？或者输入字符串?<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出, str是已定义的字符串数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">put(str);  <span class="comment">// 特别注意put不能输出多个字符串,而printf()可以。</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); <span class="comment">//由于str的值就是数组第一个元素的地址，故不需要取值符`&amp;`.同时，输入的字符串大小应不大于定义的字符数组的大小。</span></span><br><span class="line">get(str); <span class="comment">//同理，一次只能接收一个字符串数组。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">puts(str)</td>
<td style="text-align:center">输出<strong>单个</strong>字符串</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">gets(str)</td>
<td style="text-align:center">输入<strong>单个</strong>字符串</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">strlen(str)</td>
<td style="text-align:center">测量字符串的长度</td>
<td style="text-align:center">返回字符串的长度(不包括<code>\0</code>)</td>
</tr>
<tr>
<td style="text-align:center"><strong>sizeof(str)</strong></td>
<td style="text-align:center">测量字符串的内存大小</td>
<td style="text-align:center">返回字符串的内存大小(注意，如果字符串没规定大小，如<code>char str[] = &quot;string&quot;;</code>,则返回值包括<code>\0</code>,如果规定大小了，则返回的值该大小所占字节。)</td>
</tr>
<tr>
<td style="text-align:center">补充：sizeof(array)</td>
<td style="text-align:center">测量其他类型数组的内存大小</td>
<td style="text-align:center">返回其他类型数组的内存大小(此时并没有<code>\0</code>的烦恼了)</td>
</tr>
<tr>
<td style="text-align:center">strcat(str1, str2)</td>
<td style="text-align:center">将<strong>字符串2</strong>接到<strong>字符串1</strong>后面</td>
<td style="text-align:center">返回的是字符串1的地址</td>
</tr>
<tr>
<td style="text-align:center">strcpy(str1, str2)</td>
<td style="text-align:center">将字符串2(包括<code>\0</code>)复制到字符串1中</td>
<td style="text-align:center">返回的是字符串1的地址</td>
</tr>
<tr>
<td style="text-align:center">strncpy(str1, str2, n)</td>
<td style="text-align:center">将字符串2前n个字符复制到字符串1中</td>
<td style="text-align:center">返回的是字符串1的地址</td>
</tr>
<tr>
<td style="text-align:center">strlwr(str)</td>
<td style="text-align:center">将字符串中大小写字母变成<strong>小写字母</strong></td>
<td style="text-align:center">不返回任何值，对于字符串是原位修改</td>
</tr>
<tr>
<td style="text-align:center">strupr(str)</td>
<td style="text-align:center">将字符串中大小写字母变成<strong>大写字母</strong></td>
<td style="text-align:center">不返回任何值，对于字符串是原位修改</td>
</tr>
<tr>
<td style="text-align:center">strcmp(str1, str2)</td>
<td style="text-align:center">依次比较str1和str2中字符的大小，按照ASCII码比较</td>
<td style="text-align:center">str1==str2,则返回0；str1 &gt; str2,则返回一个正整数;str1 &lt; str2，则返回一个负整数.</td>
</tr>
</tbody>
</table>
</div>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针与指针变量"><a href="#指针与指针变量" class="headerlink" title="指针与指针变量"></a>指针与指针变量</h3><p>指针变量也是一个变量，占用的字节大小取决于其<strong>存储的内存地址</strong>的大小，而常说的指针应该是指针变量，其值是“内存地址”（指针）。<br><strong>需要说明的是</strong>：后续所讲<code>指针</code>多指<code>指针变量</code>,例如p指向变量a,完整的说法是：p的值是变量a的地址。</p>
<p>前提:int x = 10, *y; y = &x;<br><strong>重点：可以认为*y == x。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指针变量，&amp;为取地址运算符</span></span><br><span class="line"><span class="type">char</span> *pa = &amp;a;   <span class="comment">//用char是因为指针变量所储存的内存地址所对应的数据类型是char.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pa); <span class="comment">//打印内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*pa); <span class="comment">//打印变量a的值，这里*是取值运算符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也即：</span></span><br><span class="line">*(&amp;a) = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>下面以小甲鱼的一道课后习题来介绍：<br>Q:请问下边代码执行后，打印机的结果是什么？另外，*b 是左值（l-value）还是右值（r-value）？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">110</span>;</span><br><span class="line">   <span class="type">int</span> *b = &amp;a;</span><br><span class="line">   *b = *b - <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>打印结果是 a = 10.</p>
</blockquote>
<p>第一个问题：定义指针变量 b 的时候，存放的是变量 a 的地址。在此之后，*b 即对变量 a 的间接访问（通过地址访问 a 变量）。所以 *b = *b - 10; 相当于 a = a - 10; 也就是说，<strong>通过指针对一个变量间接访问，你可以理解为把它作为那个变量本身使唤</strong>（即 *b == a）.</p>
<p>第二个问题：<strong>指针变量 b 既是左值，也是右值</strong>。</p>
<p>此外，关于取址符（&amp;）还有个疑问：一般来说取址符作用对象是左值（lvalue），而数组名不是左值，为啥取址符还可以作用于数组名？<br>A：其实左值下面有个子集——可修改的左值，位于等式左边必须要求可修改的左值！由此可见，之前一直存在认知误区，其实数组名是左值，只是不可修改罢了。于是有以下结论：</p>
<ul>
<li>取址符作用于左值，数组名是左值（不可修改的左值），故可将取址符作用于数组名！！！</li>
</ul>
<p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/imred/article/details/45441457">数组和指针的区别</a></p>
<h3 id="一维数组与指针的关系"><a href="#一维数组与指针的关系" class="headerlink" title="一维数组与指针的关系"></a>一维数组与指针的关系</h3><p>(不特别说明，数组均指一维数组)<br><strong>数组名==指针变量</strong>，数组名储藏着数组第一个元素的地址，对于<strong>字符数据类型</strong>，可以直接用指针创建数组，下面代码演示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = <span class="string">&quot;OUC&quot;</span>;  </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]); <span class="comment">//此处相当于是 a[i] = *(a+i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然而对于int等类型，通过指针创建是行不通，究其原因，是因为字符数组就是第一个字符的地址（指针变量），且字符数组名和其他数组名一样，也是指针变量，指向数组第一个元素。</p>
<blockquote>
<p>char str[] = “string”;<br>上述str和”string”都可以当作指针变量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*(<span class="string">&quot;sting&quot;</span>)); <span class="comment">//会输出&#x27;s&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过指针访问数组</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d, *(p+1) = %d.\n&quot;</span>,*p, *(p+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果就是:</p>
<blockquote>
<p>*p = 1, *(p+1) = 2.</p>
</blockquote>
<p>这就是通过<strong>指针间接访问数组的办法，区别于下标直接访问法</strong>。<br>此处要注意的是，只有当指针指向数组元素时，指针算术运算才有意义，否则就会给未用地址乱赋值，就会报错(Segmetation default)。<br>既然数组名也是一个指针变量，那么同理也用数组名进行访问，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d, *(a+1) = %d.\n&quot;</span>,*a, *(a+<span class="number">1</span>));  <span class="comment">//这个为后续指针数组做下铺垫，例如int (*ptr)[5] = &amp;a;  这里ptr是一个指针变量，存着数组a的地址，*ptr就是数组a，也就代表着数组第一个元素的地址。从而有</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int (*ptr)[5] = &amp;a;</span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    for (i = 0; i&lt;5; i++)&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d&quot;,*(*ptr+i));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>⭐⭐⭐同时又可以发现：<strong>指针所指向的数据类型决定指针的跨度。</strong></p>
<h3 id="指针与数组的区别"><a href="#指针与数组的区别" class="headerlink" title="指针与数组的区别"></a>指针与数组的区别</h3><p>指针变量是左值(lvalue)，可以修改的；而数组名是地址常量，不可以修改，故不是左值。<br>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> str[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *target = str;  </span><br><span class="line">    <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*target++ != <span class="number">3</span>)  <span class="comment">//此处必须用指针变量，不能用数组名。</span></span><br><span class="line">    <span class="comment">// 这里*target++是啥呢？ 由于增运算符(变量++)的优先级大于取值运算符(*)，故先进行target++,再取值*，相当于*(target++)。</span></span><br><span class="line">    <span class="comment">//同时，还需注意，自增运算符在变量后面，故取值符(*)取用的是未自增前的值。</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总共有%d个数字\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>小甲鱼作业S1E22第2题</strong>：</p>
<blockquote>
<p>请问 str[20] 是否可以写成 20[str]？<br>A: C 语言中，<code>a[b]</code> 被解释为 <code>*(a + b)</code>,故两者等价。</p>
</blockquote>
<h3 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h3><p>指针数组是指数组元素全为指针的数组；数组指针是一个指针，它指向的是一个数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区分下列哪个是指针数组，哪个是数组指针</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>];  <span class="comment">//int (*p)[5]就相当于int a[5]，a就是数组地址！！！ (区别于数组首地址，后面会讲到)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ ]优先级大于*；虽然[]和()优先级一样，但结合性是从左到右，故第一个是指针数组，第二个是数组指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>指针数组的一个用途：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *p[<span class="number">3</span>] = &#123;   <span class="comment">//由于指针数组存放的都是指针，而数组名就是指针变量。</span></span><br><span class="line">        <span class="string">&quot;让编程改变世界&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Just do it!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;一切皆有可能&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[i]);  <span class="comment">// %s是通过字符串首地址输出字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关于数组指针还有一个坑，数组指针指向的是一个数组，而我们之前常用<code>int *p = temp;</code>(此处temp是一个已定义的整型数组)来将<code>指针指向数组</code>,但实际上，<strong>指针只是指向了数组第一个元素的地址</strong>。现在我们要想数组指针指向整个数组，需使用<code>int (*p)[5] = &amp;temp</code>;这里<code>&amp;temp</code>相当于将整个数组看作一个整体来看待的。(必须清楚的是，数组第一个元素的地址跟整个数组的地址是相同的。)举例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// int (*p)[5] = temp;  //输出也可以，因为把数组当作整体给出地址还是数组首地址，但编译器会提醒。</span></span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;temp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*p + i)); </span><br><span class="line">        <span class="comment">// p是一个指向数组(并非指向数组第一个元素)的指针，*p就是取出该指针对应的内容，也就是数组temp，即*p=temp，而temp又是数组第一个元素的地址，可以当作指针，并进行指针运算。</span></span><br><span class="line">        <span class="comment">//注意，此时*(*p) = *(temp) = 数组temp的第一个元素.有点嵌套指针的意味了！</span></span><br><span class="line">        <span class="comment">//于是，上述输出也可写成: printf(&quot;%d\n&quot;,(*p)[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>小甲鱼课后作业：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[<span class="number">5</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;FishC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Five&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Star&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Good&quot;</span>,</span><br><span class="line">        <span class="string">&quot;WoW&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> *(*p)[<span class="number">5</span>] = &amp;<span class="built_in">array</span>;  <span class="comment">//定义指向包含5个指针的数组的指针，也就是说这个数组的类型是字符指针类型，故定义相同类型(char *)的数组指针</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; *(*(*p+i)+j) != <span class="string">&#x27;\0&#x27;</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,*(*(*p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此处<code>p</code><strong>实际上是指向包含5个指针的数组，最好写成char<em> (</em>p)[5] = array;</strong></p>
<h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>观察下述代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array is %p\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array +1 is %p\n&quot;</span>,<span class="built_in">array</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>输出结果是：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array is 0xbfc34320<span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>+1 is 0xbfc34334</span><br></pre></td></tr></table></figure><br>由此得出，二维数组的数组名指向包含5个元素的数组(也就是第一行元素所构成的数组)，<strong>二维数组名实际上就是数组指针</strong>！！！<br>同时也可明白，<code>array + 1</code>则指向第二行构成的数组，即此处的<code>array +1</code>相当于前述的<code>p</code>.   </p>
<p>二维数组名也可赋值给数组指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>] = <span class="built_in">array</span>; <span class="comment">// p指向第一行元素构成的数组</span></span><br><span class="line">    <span class="type">int</span> (*n)[<span class="number">3</span>] = <span class="built_in">array</span> + <span class="number">1</span>;<span class="comment">// n指向第二行元素构成的数组</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*p)[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*n)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p); <span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,<span class="built_in">array</span>);<span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;(*<span class="built_in">array</span>)); <span class="comment">// 输出第一行元素构成的数组的地址。(注意，并非数组的第一个元素，尽管两者数值上相等。)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p); <span class="comment">//输出第一行元素构成的数组的第一个元素的地址。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**(p+<span class="number">1</span>));<span class="comment">// p是第一行元素构成的数组的地址，(p+1)则是第二行元素构成的数组的地址。</span></span><br><span class="line">    <span class="comment">//因为二维数组在内存中也是线性存储的，p+1表示指针往后移3*4=12个字节，也就是第二行元素构成的数组的地址。</span></span><br><span class="line">    <span class="comment">//即p+1指向第二行元素构成的数组。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="void指针与NULL指针"><a href="#void指针与NULL指针" class="headerlink" title="void指针与NULL指针"></a>void指针与NULL指针</h3><p>void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，<strong>任何类型的指针都可以赋值给void指针。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;num;</span><br><span class="line">    <span class="type">char</span> *n = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *ye;</span><br><span class="line"></span><br><span class="line">    ye = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ye:%p p:%p\n&quot;</span>,ye,p);</span><br><span class="line">    ye = n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ye:%p n:%p\n&quot;</span>,ye,n); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>于是，又引出几个问题：</p>
<ol>
<li>void指针如何取值？编译器怎么知道？<ul>
<li>所以，强制转换符<code>(强制转换类型 *)</code>又出现了。</li>
</ul>
</li>
<li>对于 void指针 <code>p</code>，<code>p + 1</code>移动多少个字节？<ul>
<li>由于编译器不知道其指向的数据类型，故只移动一个字节。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ye:%d\n&quot;</span>,*((<span class="type">int</span> *)ye));  </span><br></pre></td></tr></table></figure>
NULL指针，即空指针，不指向任何一个地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空指针的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NULL ((void *)0)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;  <span class="comment">//定义空指针，解引用(取值)的话程序会报错。</span></span><br><span class="line"><span class="comment">//也可以写成 int *p = (void *)0 ;</span></span><br><span class="line"><span class="type">int</span> *m; <span class="comment">//还未初始化，称为野指针。</span></span><br></pre></td></tr></table></figure>
注意，是NULL而不是NUL（在ASCII表中）。</li>
</ul>
<ol>
<li>NULL用于指针和对象，表示控制，指向一个不被使用的地址。</li>
<li>NUL(‘\0’)表示字符串的结尾。</li>
</ol>
</li>
</ol>
<p>小甲鱼S1E24：指针和二维数组第5题出现了<code>(int (*)[3])</code>强制类型转换符。具体代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">array</span>[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> (*p)[<span class="number">3</span>] = (<span class="type">int</span> (*)[<span class="number">3</span>])&amp;<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>(int (*)[3])&amp;array</code>等号右边强制将 array 这个一位数组重新划分成3*3的二维数组，p等于二维数组。这与前面第6条所说：<code>二维数组名就是数组指针</code>相呼应。小甲鱼的答案有点问题，p并不是指向二维数组，p就是二维数组名，指向二维数组第一行元素构成的数组。</p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;  <span class="comment">//此即指向指针的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证是否指向指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n*pp = %p&quot;</span>,p,*pp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那指向指针的指针有啥用呢？观察如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *cBooks[] = &#123;</span><br><span class="line">        <span class="string">&quot;C primer plus&quot;</span>,</span><br><span class="line">        <span class="string">&quot;带你学C带你飞&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C与指针&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> **charm;</span><br><span class="line"></span><br><span class="line">    charm = &amp;cBooks[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,*charm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由此可以看出，指向指针的指针至少有以下两个好处：</p>
<ul>
<li>避免重复分配内存；</li>
<li>只需对一处进行修改.</li>
</ul>
<h3 id="指向指针的指针与二维数组"><a href="#指向指针的指针与二维数组" class="headerlink" title="指向指针的指针与二维数组"></a>指向指针的指针与二维数组</h3><p>观察如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> **p = <span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(*(p+i)+j));   <span class="comment">//对应着case one</span></span><br><span class="line">        <span class="comment">//printf(&quot;%d&quot;,*(*(array+i)+j));  //对应case two</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Case one:</p>
<blockquote>
<p>由于p是一个指针，故p+i就是指针移动<code>i</code>个<code>int</code>数据类型所占的字节。例如，i = 1,则p+1就是第一行元素构成数组的地址+4，如果再取值<code>*</code>,由于找不到对应的内容(因为无论是整个数组地址还是数组第一个元素的地址，数值上都等于数组第一个元素的地址，且二维数组的行并不一定在内存中是连续存储的。）因此，使用错误的指针类型可能导致对内存的错误访问，从而触发段错误<code>sgementation default</code>。</p>
</blockquote>
<p>Case two:</p>
<blockquote>
<p>array可行，因为array本身可看作数组指针，array+1就是移向下一行。</p>
</blockquote>
<p>因此，要想正确输出，需将上述代码改为如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = <span class="built_in">array</span>;  <span class="comment">//利用数组指针</span></span><br></pre></td></tr></table></figure><br>这里值得注意的是：</p>
<ol>
<li>因为array实际上是第一行元素的构成的数组的地址，<code>[num]</code>中<code>num</code>必须要和该数组元素个数相等。p指向一个4个元素的数组，则<code>p + 1</code>移动<code>sizeof(int) * 4</code>个字节。而如果是<code>*p</code>,此时<code>*p</code>是指向第一行元素的构成的数组的第一个元素，此时<code>*p + 1</code>移动<code>sizeof(int)</code>个字节。</li>
<li>由上可见，<strong>正如第2条最后所说，指针所指向的数据类型决定指针的跨度</strong>。</li>
</ol>
<p>小试牛刀：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="string">&quot;How are you?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;I&#x27;m fine, thanks&quot;</span>,</span><br><span class="line">        <span class="string">&quot;and you?&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span>* (*p)[<span class="number">4</span>]  = &amp;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(*p)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Ps:B站这一节课有弹幕指出：可以写成<code>(*p)[3][4] = &amp;array</code>,这个其实相当于定义了一个指向二维数组的指针。代码可修改如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>][<span class="number">4</span>] = &amp;<span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,*(*(*p+i)+j)); <span class="comment">//由于p指向整个二维数组，故*p就是二维数组，指向二维数组第一行元素构成的数组，这样也就弱化为指向数组的指针了，同前述第6节。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="常量和指针"><a href="#常量和指针" class="headerlink" title="常量和指针"></a>常量和指针</h3><p>常量：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">520</span>, <span class="string">&#x27;A&#x27;</span>, <span class="params">...</span></span><br></pre></td></tr></table></figure><br>常变量:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">//这样使得a只能读，不能修改，相当于常量，但不是常量.</span></span><br></pre></td></tr></table></figure><br>定义指向常量的指针(<strong>区别于后续所讲常量指针</strong>):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;num;  <span class="comment">//定义指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针指向的值，则会发生错误</span></span><br><span class="line">*p = <span class="number">1250</span>;</span><br><span class="line"><span class="comment">//error: assignment of read-only location &#x27;*p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针的值，这是允许的，相当于该指针不指向常量num.</span></span><br><span class="line"><span class="type">int</span> cnum = <span class="number">250</span>;</span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//编译通过。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时如果改变p指向的值，则报错：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//但是，我们如果修改cnum的值：</span></span><br><span class="line">cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功。</span></span><br></pre></td></tr></table></figure><br>指向常量的指针-总结：</p>
<ul>
<li>指针可以修改为指向不同的常量</li>
<li>指针可以修改为指向不同的变量</li>
<li>可以通过解引用来读取指针指向的数据</li>
<li>不可以通过解引用修改指针指向的数据</li>
</ul>
<p>那什么是常量指针呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num; <span class="comment">//定义指向非常量的常量指针</span></span><br></pre></td></tr></table></figure><br>特性：</p>
<ul>
<li>指针本身值不可改变，指向的值可修改。</li>
<li><strong>典型例子就是数组名</strong>。</li>
</ul>
<p>定义指向非常量的常量指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指向的值：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改本身值：</span></span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//报错：error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><br>如果定义一个指向常量的常量指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;cnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此时既修改指针的值，又修改指针所指向的值，则会报两个错：</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line">p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error:error: assignment of read-only location &#x27;*p&#x27;;</span></span><br><span class="line"><span class="comment">// error:error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><br>可以看出其特点：</p>
<ul>
<li>指针本身值不可改变，指向的值也不可修改。</li>
</ul>
<p>但有趣的一点是，如果你定义了指向常量的常量指针，但接受的地址不是常量，还是可以通过改变该非常量来修改指针所指向的值的。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line">num = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出111.</span></span><br></pre></td></tr></table></figure><br>又进一步引出：指向 “指向常量的常量指针” 的指针。<br>看到名字别害怕，<strong>去掉定语，也即指向指针的指针</strong>。</p>
<blockquote>
<p>要记住:一般来说，<strong>要指向 “常量指针”，自己也必须是指向常量的指针。</strong><br>但如果自己不是指向常量的常量指针也可以的，不过会有<code>warning</code>, 后面详细介绍了<code>const的约束对象</code>，理解将会更加深刻。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> **  pp = &amp;p; <span class="comment">//定义指向 “常量指针” 的指针</span></span><br><span class="line"><span class="comment">//上行代码也可以写成（但不推荐）：</span></span><br><span class="line"><span class="comment">//int **p = &amp;p;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证pp指向p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pp = %p, &amp;p = %p\n&quot;</span>,pp,&amp;p);</span><br><span class="line"><span class="comment">//验证*pp == p == &amp;num</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pp = %p, p = %p,&amp;num = %p\n&quot;</span>,*pp,p,&amp;num);</span><br><span class="line"><span class="comment">//验证**pp == *p == num;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**pp = %d, *p = %d, num = %d\n&quot;</span>,**pp,p,num);</span><br></pre></td></tr></table></figure></p>
<p>小甲鱼S1E27：常量和指针， 关于<code>const的约束对象</code>：<br>请问在下边声明中，const 限制的是 q、*q 还是 **q？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> *q = &amp;p;</span><br><span class="line"></span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>答： 第一个const限制<code>**q</code>(即指针的两次解引用，可以理解为num,但不是num.因为num如果是<code>int num = 250</code>,那么num还是可以修改的，而<code>**q</code>则是不可以的。),第二个const限制<code>*q</code>(同上述理);</p>
<p>记住一点：<strong>const 永远限制紧随着它的标识符</strong>。那么，如果想要使用 const 同时限制 q、*q 和 **q，应该怎么做？</p>
<blockquote>
<p>const int * const * const p; 或者int const * const * const p; 因为<code>const *p</code>等价于 <code>int const *p</code>; 但一般为了可读性，就不写成<code>int const *p</code>,但<code>int const *p</code>更能体现这句话—-const 永远限制紧随着它的标识符.</p>
</blockquote>
<p>于是又有人问了，<code>const int const **p</code>; 限制了啥？</p>
<blockquote>
<p>其实只限制了<code>**p</code>.</p>
</blockquote>
<p>重点：限制了谁谁就变可读了，不能修改（也就不是可修改的左值了）。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数初体验"><a href="#函数初体验" class="headerlink" title="函数初体验"></a>函数初体验</h3><ol>
<li>C语言程序编译的时候是从上至下，执行的时候是从main()函数开始的。</li>
<li>void函数不返回任何值，因此不需要加<code>return xxx  ;</code></li>
<li>养成好习惯：要使用某个函数<code>int func()</code>，先进行声明<code>int func();</code>,千万别丢了分号<code>;</code>.<br>函数声明时，既可带上参数名，也可不带。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>如果定义一个与标准库函数重名的函数，会怎样？<ul>
<li>重新定义的同名函数会覆盖标准库函数（前提是两者的声明一致，包括返回值和参数类型、个数一致）。</li>
</ul>
</li>
</ol>
<h3 id="参数和指针"><a href="#参数和指针" class="headerlink" title="参数和指针"></a>参数和指针</h3><ol>
<li><p>传值和传址<br>观察下列两个代码：<br><strong>传值：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line">    swap(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<blockquote>
<p>交换前: x = 3, y = 5<br>交换后: x = 3, y = 5</p>
</blockquote>
<p><strong>传址：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line">    swap(&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<blockquote>
<p>交换前: x = 3, y = 5<br>交换后: x = 5, y = 3</p>
</blockquote>
</li>
</ol>
<p>   为啥结果会不同呢？<br>   因为函数swap(int x, int y)会给x,y单独在内存中找两段储存空间(可理解为局部变量)，<strong>存放传进来的值</strong>，对原来地址上的值无影响。如果传给函数的本就是地址，则函数内部调用时，就是直接对原来地址上的值进行操作。</p>
<ol>
<li>传数组<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_array</span><span class="params">(<span class="type">int</span> b[])</span>; <span class="comment">//由于传递数组本质是传递数组第一个元素地址，此处可以不写数组元素个数。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_array</span><span class="params">(<span class="type">int</span> b[])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof b: %d\n&quot;</span>,<span class="keyword">sizeof</span>(b)); <span class="comment">//由于传递的是一个地址，也就是指针，取决于操作系统。我的操作系统是64位，故返回8。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof a: %d\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    get_array(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
<li><p>可变参数<br>首先需要调用<code>stdarg.h</code>头文件，具体实现原理可见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/clover-toeic/p/3736748.html">可变参数详解</a>，常见用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">VarArgFunc</span><span class="params">(<span class="type">int</span> dwFixedArg, ...)</span>&#123; <span class="comment">//以固定参数的地址为起点依次确定各变参的内存起始地址</span></span><br><span class="line"></span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;  <span class="comment">//定义va_list类型的指针pArgs，用于存储参数地址</span></span><br><span class="line"></span><br><span class="line">    va_start(pArgs, dwFixedArg); <span class="comment">//初始化pArgs指针，使其指向第一个可变参数。该宏第二个参数是变参列表的前一个参数，即最后一个固定参数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dwVarArg = va_arg(pArgs, <span class="type">int</span>); <span class="comment">//该宏返回变参列表中的当前变参值并使pArgs指向列表中的下个变参。该宏第二个参数是要返回的当前变参类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若函数有多个可变参数，则依次调用va_arg宏获取各个变参</span></span><br><span class="line"></span><br><span class="line">    va_end(pArgs);  <span class="comment">//将指针pArgs置为无效，结束变参的获取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Code Block using variable arguments */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_arg</span><span class="params">(<span class="type">int</span> n, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func_arg</span><span class="params">(<span class="type">int</span> n, ...)</span>&#123;</span><br><span class="line">    va_list pargs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pargs,n);</span><br><span class="line">    <span class="type">int</span> i = va_arg(pargs, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    func_arg(<span class="number">10</span>);<span class="comment">//打印固定参数i堆栈上方一个内容(垃圾值)</span></span><br><span class="line">    func_arg(<span class="number">10</span>,<span class="number">5</span>);<span class="comment">//打印固定参数i堆栈上方一个内容(5)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 原理图如下所示：</p>
<div align="center"><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/可变参数堆栈.png" width="80%"></div>

<p><strong>小试牛刀</strong>：尝试实现sum()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,sum = <span class="number">0</span>;</span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pArgs,n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">        sum += va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(pArgs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>勇攀高峰</strong>：尝试自己模拟实现 printf 格式化输出的基本功能，基本要求如下：</p>
<ul>
<li>输出第一个参数中除了格式化占位符外的所有字符</li>
<li>实现 %d 的格式化输出</li>
<li>实现 %c 的格式化输出</li>
<li>实现 %s 的格式化输出</li>
<li>实现 myprintf 函数返回打印了多少字符</li>
<li><p><strong>全程仅能使用 putchar 唯一一个标准库函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span>* str,...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printstr</span><span class="params">(<span class="type">char</span>* str)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printstr</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i++]);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> dec = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = num;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt; <span class="number">9</span>)&#123;</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">        dec *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dec &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(num/dec + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        num %= dec ;</span><br><span class="line">        dec /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span>* str,...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> carg;</span><br><span class="line">    <span class="type">char</span> *sarg ;</span><br><span class="line">    <span class="type">int</span> darg;</span><br><span class="line"></span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pArgs,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str[i++]);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (str[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:&#123;</span><br><span class="line">                    sarg = va_arg(pArgs,<span class="type">char</span>*);</span><br><span class="line">                    num += printstr(sarg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:&#123;</span><br><span class="line">                    carg = va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">                    <span class="built_in">putchar</span>(carg);</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:&#123;</span><br><span class="line">                    darg = va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">                    num += printint(darg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(pArgs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    i = myprintf(<span class="string">&quot;Hello %s\n&quot;</span>, <span class="string">&quot;FishC&quot;</span>);</span><br><span class="line">    myprintf(<span class="string">&quot;共打印了%d个字符(包含\\n)\n&quot;</span>, i);</span><br><span class="line">    i = myprintf(<span class="string">&quot;int: %d, char: %c\n&quot;</span>, <span class="number">-520</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    myprintf(<span class="string">&quot;共打印了%d个字符(包含\\n)\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="指针函数与函数指针"><a href="#指针函数与函数指针" class="headerlink" title="指针函数与函数指针"></a>指针函数与函数指针</h3><ol>
<li>指针函数<br>定义：使用<strong>指针变量作为函数的返回值</strong>的函数，就是指针函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">pointer</span><span class="params">()</span>; <span class="comment">//写成 char* pointer();可能更好理解，但遵循一般习惯，就这样吧。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">pointer</span><span class="params">()</span>&#123;</span><br><span class="line"> ...;</span><br><span class="line"> <span class="keyword">return</span> 字符指针;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
需要特别注意的是：<strong>不要返回局部变量的指针！！！</strong><br>举例如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_word</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_word</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要写成下面这样，因为函数一结束，所有变量值会被清理掉，虽然返回了变量的地址，但该地址上啥值也没有。</span></span><br><span class="line"><span class="comment">// char *get_word(char c)&#123;</span></span><br><span class="line"><span class="comment">//     char str1[] = &quot;Apple&quot;;</span></span><br><span class="line"><span class="comment">//     char str2[] = &quot;Banana&quot;;</span></span><br><span class="line"><span class="comment">//     char str3[] = &quot;Cat&quot;;</span></span><br><span class="line"><span class="comment">//     char str4[] = &quot;Dog&quot;;</span></span><br><span class="line"><span class="comment">//     char str5[] = &quot;None&quot;;</span></span><br><span class="line"><span class="comment">//     switch (c)&#123;</span></span><br><span class="line"><span class="comment">//         case &#x27;A&#x27;: return str1;</span></span><br><span class="line"><span class="comment">//         case &#x27;B&#x27;: return str2;</span></span><br><span class="line"><span class="comment">//         case &#x27;C&#x27;: return str3;</span></span><br><span class="line"><span class="comment">//         case &#x27;D&#x27;: return str4;</span></span><br><span class="line"><span class="comment">//         default: return str5;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要查询的字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,get_word(c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可能又有人问了，为啥可以直接返回字符串”Apple”…哪些呢？<br>参考ChatGPT回答:<div align="center"><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/指针函数与函数指针_局部变量的指针.jpg" width="90%"></div></li>
<li>函数指针<br>定义：指向函数的指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> num*num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>); <span class="comment">//定义函数指针，此处第一个int取决于所指向的函数的返回值，第二个int取决于函数的输入参数。就跟函数定义时相同即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化函数指针</span></span><br><span class="line">fp = square;     <span class="comment">//也可以写成fp = &amp;square; 但没必要，因为一般来说，函数编译后，函数名就是函数的地址。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在主函数中通过函数指针调用函数</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*fp)(num));</span><br><span class="line"><span class="comment">//其实也可以写成 printf(&quot;%d&quot;,fp(num)); 但为了与函数混淆，还是写成上面那种形式比较好。</span></span><br></pre></td></tr></table></figure>
需要注意的就是函数编译后，函数名就是函数指针。</li>
<li>函数指针作为参数<br>举个栗子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数指针作为参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1 ,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 + 5 = %d\n&quot;</span>,calc(add,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 - 5 = %d\n&quot;</span>,calc(sub,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数指针作为返回值<br>接着上节，举个栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span>))(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">//定义一个参数为char类型，返回值为函数指针的函数.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1 ,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为返回值</span></span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span> op))(<span class="type">int</span> num1, <span class="type">int</span> num2)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> add;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入计算表达式:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;num1,&amp;op,&amp;num2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>,num1,num2,calc(select(op),num1,num2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面，我们可以发现，定义返回值类型为函数指针,参数类型为字符的函数，且所返回的函数指针指向的函数接收两个int类型参数且返回值为int类型的操作为： <code>int (*func(int))(int, int);</code>.<br>函数拓展 &gt;&gt; <code>snprintf函数</code>，函数详解-&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-68870-1-1.html">传送门</a>.<br>举个栗子😊：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">42</span>;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//将整数42以16进制数的形式写入字符数组</span></span><br><span class="line">    <span class="comment">//42(10) == 2a(16)</span></span><br><span class="line">    <span class="built_in">snprintf</span>(<span class="built_in">array</span>,<span class="number">3</span>,<span class="string">&quot;%02x&quot;</span>,c);</span><br><span class="line">    <span class="comment">//打印字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">array</span>); <span class="comment">//  输出结果为2a，从而印证上述说法.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><ol>
<li><p>局部变量<br>局部变量（Local Variables）是指在特定范围内声明和使用的变量。这个特定的范围通常是在一个函数或者一个代码块内部。<br>特定范围中一个函数的情况很常见，对于代码块内部，下面举一例进行说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;before, i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;after, i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>for</code>循环内部的i只作用于该循环，且循环内部调用的i只能是<code>int i = 0</code>这里定义的。在<code>for</code>循环外面调用的i就是<code>int i = 520;</code>这里定义的！！！<br>如下图所示：<br><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/循环内局部变量作用范围.jpg" alt="循环内局部变量"></p>
<blockquote>
<p>不过要注意的是，C99才允许上述在<code>for</code>语句中定义变量。因为C99允许在使用时才定义变量，而不是一开始在最上面定义变量。</p>
</blockquote>
</li>
<li><p>全局变量<br>在函数里面定义的，我们叫局部变量；在函数外部定义的，我们叫外部变量，也叫做<strong>全局变量</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   a();</span><br><span class="line">   b();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><strong>如果不对全局变量进行初始化，那么它会自动初始化为0</strong>。</li>
<li>如果在函数的内部存在一个与全局变量同名的局部变量，编译器并不会报错，而是在函数中屏蔽全局变量（也就是说在这个函数中，全局变量不起作用)。</li>
</ul>
<p>举例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">   a = <span class="number">880</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line">   func();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a + b = <span class="number">520</span></span><br><span class="line">a + b = <span class="number">1000</span></span><br><span class="line">a + b = <span class="number">1400</span></span><br></pre></td></tr></table></figure>
<p>一般来说编译器不允许先使用变量再定义，否则会报错；<br>但是如果我们使用关键字<code>extern</code>，则是可以的。该关键字的功能就是告诉编译器，我是定义了这个变量的，只不过在后面；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="作用域与链接属性"><a href="#作用域与链接属性" class="headerlink" title="作用域与链接属性"></a>作用域与链接属性</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域包括以下几种类型：</p>
<ul>
<li>代码块作用域</li>
<li>文件作用域</li>
<li>原型作用域</li>
<li>函数作用域</li>
</ul>
<div class="tabs" id="作用域"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="作用域-1">代码块作用域</button><button type="button" class="tab " data-href="作用域-2">文件作用域</button><button type="button" class="tab " data-href="作用域-3">原型作用域</button><button type="button" class="tab " data-href="作用域-4">函数作用域</button></ul><div class="tab-contents"><div class="tab-item-content active" id="作用域-1"><p>在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志该代码块结束的右大括号(})处。<br>另外，尽管函数的形式参数不在大括号内定义，但其同样具有代码块作用域，隶属于包含函数体的代码块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">120</span>;</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">130</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">130</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="作用域-2"><p>任何在<strong>代码块之外声明的标识符</strong>都具有文件作用域，作用范围是从它们声明位置开始，到文件的结尾处结束。另外，函数名也具有文件作用域，因为函数名本身也在代码块之外。</p>
<blockquote>
<p>定义了一定是声明了！！！典型的就是全局变量的定义，故作用范围是从定义的位置开始，到文件结尾处结束！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> count;   <span class="comment">//全局变量声明。当然也可以直接定义，例如在main函数前面写 int count = 0;</span></span><br><span class="line">    func();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main, count = %d\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func, count = %d\n&quot;</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In func, count = <span class="number">1</span></span><br><span class="line">In main, count = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>很显然，如果没有声明(<code>void func()</code>和<code>extern int count</code>)，那么编译器也不知道后面会有func和count，就报个错先！<br>进一步，可以看出，具有文件作用域的标识符包括<strong>函数名和全局变量</strong>！</p></div><div class="tab-item-content" id="作用域-3"><p>原型作用域(prototype scope)<strong>只适用于那些在函数原型中声明的参数名</strong>。我们知道，函数在声明的时候可以不写参数的名字（但参数类型是必须要写上的），其实尝试一下还可以发现，<strong>函数原型</strong>的参数名还可以随便写一个名字，不必与<strong>函数定义</strong>时的形式参数相匹配（当然，这样做毫无意义)。之所以允许这么做，是因为原型作用域起了作用。<br><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/原型作用域.jpg" alt="原型作用域"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型（亦称为函数声明）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="作用域-4"><p>函数作用域只适用于语句标签（而语句标签用于goto语句）。使用规则：一个函数的所有语句标签必须唯一。<br>goto语句的作用域是一个函数的大小，而不是一个代码块。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<h4 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h4><p>啥是链接？可能刚开始比较疑惑，那就看看C语言源代码是如何编程可执行文件(.exe)的吧！—&gt;传送门:[]<br>链接属性分类：</p>
<ul>
<li>external（外部属性）：多个文件中声明的同名标识符表示同一个实体。</li>
<li>internal（内部属性）：单个文件中声明的同名标识符表示同一个实体。</li>
<li>none（空链接属性）：声明的同名标识符中被当作不同独立的实体。比如，函数的局部变量，因为它们被当作独立不同的实体，所以不同函数间同名的局部变量并不会发生冲突。</li>
</ul>
<p>特点：</p>
<ul>
<li><strong>只有具备文件作用域的标识符才能拥有external或internal的链接属性</strong>，其他作用域的标识符都是none属性。</li>
<li>默认情况下，具备文件作用域的标识符拥有external属性。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   a();</span><br><span class="line">   b();</span><br><span class="line">   c();</span><br><span class="line">   b();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>static</strong>关键字对<strong>链接属性</strong>的修改：</p>
<ol>
<li>使用static关键字修改链接属性，<strong>只对具有文件作用域的标识符生效</strong>（对于拥有其他作用域的标识符是另一种功能）。(当然只是对链接属性进行了修改，<strong>作用域还是没变</strong>！！！)</li>
<li><strong>链接属性只能修改一次</strong>，也就是说，一旦将标识符的链接属性变为internal,就无法再变回external了。</li>
</ol>
<p>这样做的好处就是保护全局变量，以免在其他文件中被修改！</p>
<p>本节作用域与链接属性是从空间角度分析的，下面将从时间角度作为切入点！！！</p>
<h3 id="生存期与存储类型"><a href="#生存期与存储类型" class="headerlink" title="生存期与存储类型"></a>生存期与存储类型</h3><h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>C语言拥有两种生存期：</p>
<ul>
<li>静态存储期(static storage duration)</li>
<li>自动存储期(automatic storage duration)</li>
</ul>
<div class="tabs" id="生存期"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="生存期-1">静态存储期</button><button type="button" class="tab " data-href="生存期-2">自动存储期</button></ul><div class="tab-contents"><div class="tab-item-content active" id="生存期-1"><p><strong>具有文件作用域的变量</strong>属于静态存储期，函数也属于静态存储期。属于静态存储期的变量在程序执行期间将一直占据存储空间，<strong>直到程序关闭才释放</strong>。</p></div><div class="tab-item-content" id="生存期-2"><p><strong>具有代码块作用域的变量</strong>一般情况下属于自动存储期。属于自动存储期的变量在<strong>代码块结束时将自动释放存储空间</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h4><p>C语言提供了五种不同的存储类型：</p>
<ul>
<li>atuo(default)</li>
<li>register</li>
<li>静态存储变量(static)</li>
<li>static 和 extern</li>
<li>typedef</li>
</ul>
<div class="tabs" id="存储类型"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="存储类型-1">自动变量(auto)</button><button type="button" class="tab " data-href="存储类型-2">寄存器变量(register)</button><button type="button" class="tab " data-href="存储类型-3">静态局部变量(static)</button><button type="button" class="tab " data-href="存储类型-4">static 和 extern</button><button type="button" class="tab " data-href="存储类型-5">typedef</button></ul><div class="tab-contents"><div class="tab-item-content active" id="存储类型-1"><p><strong>默认适用对象</strong>：函数中的形参、局部变量及复合语句中定义的局部变量等；<br><strong>特性</strong>：拥有代码块作用域、自动存储期和空连接属性(None);<br>在代码块中声明的变量默认的存储类型就是<code>auto</code>，不过auto可以省略，平常我们写的时候就省略了。<br>不过当强调局部变量屏蔽全局变量这一做法时，可以在局部变量前加上auto。</p></div><div class="tab-item-content" id="存储类型-2"><p><strong>声明</strong>：register int i;…<br><strong>特性</strong>：</p>
<ul>
<li>代码块作用域、自动存储期和空链接属性；</li>
<li>不能通过取址运算符(&amp;)获得该变量的地址！！！</li>
</ul>
<p>将一个变量声明为寄存器变量，那么该变量就<strong>有可能</strong>被存放于位于CPU的寄存器。为啥说有可能呢？因为CPU的寄存器空间十分有限，所以编译器并不会让所有声明为register的变量都放到寄存器中。<br>事实上，有可能所有的register关键字都被忽略，因为编译器有自己的一套优化方法，会权衡哪些才是最常用的变量。在编译器看来，它比你更了解程序。而那些被忽略的register变量，它们会变成普通的自动变量。</p></div><div class="tab-item-content" id="存储类型-3"><p>首先可能有人会好奇，为啥会叫静态局部变量呢？<br>这就对了，因为static作用于全局变量时，是修改其链接属性。那么static作用于局部变量会发生什么奇妙的事情呢？<br>static作用于局部变量会使<strong>局部变量的生存期</strong>由自动存储期变为静态储存期！由此可得其特性：<br><strong>特性</strong>：空链接属性、代码块作用域、静态存储期。<br>举例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      func();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="存储类型-4"><p>此处所指static不同于前述静态局部变量所讲的static。这里所讲static和extern的作用域是文件作用域，static关键字使得默认具有external链接属性的标识符变成internal链接属性，而extern关键字告诉编译器这个变量或函数在别的地方已经定义过了，先去别的地方找找，不要急着报错。</p></div><div class="tab-item-content" id="存储类型-5"><p>该类型将在结构体章节详细阐述！！！</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>切记：递归一定要有结束条件！<br>基操：实现阶乘<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recursion(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d! = %d&quot;</span>,n,recursion(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>小试牛刀：</p>
<div class="tabs" id><ul class="nav-tabs"><button type="button" class="tab  active" data-href="-1">汉诺塔</button><button type="button" class="tab " data-href="-2">快速排序</button></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/递归-汉诺塔.jpg" alt="汉诺塔"><br>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>, <span class="type">char</span>, <span class="type">char</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> z)</span>&#123;   <span class="comment">//表示的意义为：从x移到z位置，借助y；</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        func(n<span class="number">-1</span>, x, z, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, x, z);</span><br><span class="line">        func(n<span class="number">-1</span>, y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>,y = <span class="string">&#x27;y&#x27;</span>,z = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input story:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    func(n,x,y,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="-2"><p><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/递归-快速排序.jpg" alt="快速排序"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> *p,  <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = end;</span><br><span class="line">    <span class="type">int</span> judge = p[(start+end)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (; p[i] &lt; judge; i++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; p[j] &gt; judge; j--)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = p[i];</span><br><span class="line">        p[i] = p[j];</span><br><span class="line">        p[j] = temp;</span><br><span class="line">        i++;    <span class="comment">//特别要注意，比较完之后要向中间靠拢，否则遇见p[i] == p[j]的情况就会陷入死循环！</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后i和j一定是相邻的！因为i走过的必定是满足p[i] &lt; judge，也就不可能满足p[j] &gt; judge了；同理，j走过的必定不可能满足i，故i,j最后会相邻，且i &gt; j!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; start)&#123;</span><br><span class="line">        quick_sort(p, start, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; end)&#123;</span><br><span class="line">        quick_sort(p, i, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">388</span>,<span class="number">458</span>,<span class="number">253</span>,<span class="number">245</span>,<span class="number">356</span>,<span class="number">356</span>,<span class="number">122</span>,<span class="number">223</span>,<span class="number">245</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, length;</span><br><span class="line"></span><br><span class="line">    length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    quick_sort(<span class="built_in">array</span>, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the sorted result is\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= length; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>
<h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><p>在之前所学中，变量一经定义，其内存大小就不能再更改了！那么有什么办法能让C语言更灵活地管理内存资源呢？<br>答案是有的，需要借助几个库函数，这几个库函数在<code>stdlib.h</code>这个头文件中！</p>
<h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><br>malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的指针。不过要注意，申请的这块空间并没有被“清理”（初始化为0），所以它上面的数据是随机的（就与局部变量一样）。</p>
<ul>
<li>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针(void*),所以它可以被转换成任何类型的数据：</li>
<li>如果函数调用失败，返回值是NULL。</li>
<li>另外，如果size参数设置为O,返回值也可能是NULL,但这并不意味着函数调用失败。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num is %d\n&quot;</span>,*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><br>由于malloc函数申请的空间位于内存的堆上，如果不主动释放它，那么它会一直存在直到程序结束！<br>所以以后写程序，<code>malloc</code>和<code>free</code>要成对！<br>故上面程序应该为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num is %d\n&quot;</span>,*ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);    <span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>内存泄漏指的是在程序运行过程中，动态分配的内存空间没有被正确释放的情况。导致内存泄漏主要有以下两种情况：</p>
<ol>
<li>隐式内存泄漏(即用完内存块没有及时使用free函数释放掉)；</li>
<li>丢失内存地址；</li>
</ol>
<p>丢失内存地址就是说把原本指向动态申请的内存地址的指针指向别的地方了。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">ptr = &amp;num; <span class="comment">//丢失内存地址</span></span><br></pre></td></tr></table></figure></p>
<h4 id="申请任意尺寸的内存空间"><a href="#申请任意尺寸的内存空间" class="headerlink" title="申请任意尺寸的内存空间"></a>申请任意尺寸的内存空间</h4><p>malloc不仅可以申请基本类型数据的空间，还可以申请一块任意的内存空间。对于后者，由于申请得到的空间是连续的，通常采用数组来进行索引。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于malloc并不会初始化申请的内存空间，所以需要自己进行初始化。当然可以写个循环来做这件事，但不建议这么做，标准库提供了更加高效的函数：<code>memset</code>。以mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中.—&gt;<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-80241-1-1.html">memset函数传送门</a>.</p>
<blockquote>
<p>除了memset函数之外，类似的还有memcpy，memmove，memcmp等等，可见小甲鱼函数快查.—&gt;<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-66397-1-1.html">传送门</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>,i,ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的同学可能发现了，这样每次写完<code>malloc</code>，还要再写<code>memset</code>，略显繁琐，于是C语言提供了<code>calloc</code>函数一步实现上述功能！</p>
<h4 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></p>
<p>calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间(即申请的总空间尺寸为nmemb*size)，这些内存空间全部被初始化为0。</p>
<p>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针(void*)，所以它可以被转换成任何类型的数据：如果函数调用失败，返回值是NULL。如果nmemb或size参数设置为O，返回值也可能是NULL，但这并不意味着函数调用失败。</p>
<p>calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为0，而malloc函数不进行初始化操作，里边数据是随机的。因此，下面两种写法是等价的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">8</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(ptr, <span class="number">0</span>, <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p>
<h4 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h4><p>在现实操作中，我们会经常碰到内存空间不足的问题，需要扩展，此时可以借<code>malloc</code>和<code>memccpy</code>进行扩充：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr1;</span><br><span class="line">    <span class="type">int</span> *ptr2;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ptr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>((num*<span class="number">2</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr2, ptr1, num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    ptr2[num] = <span class="number">5201314</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr2[%d] == %d\n&quot;</span>, num, ptr2[num]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr2[%d] == %d\n&quot;</span>,i, ptr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="built_in">free</span>(ptr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的操作比较繁琐，还好C语言有相应的库函数，没错，就是<code>realloc</code>!<br>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></p>
<p>不过需要注意以下几点：</p>
<ul>
<li>realloc函数将ptr指向的内存空间大小修改为size字节。</li>
<li>如果新分配的内存空间比原来的大，则旧内存块的数据不会发生改变：如果新分配的内存空间比原来的小，则可能导致数据丢失，请慎用。</li>
<li>该函数将移动内存空间的数据并返回新的指针。</li>
<li>如果ptr参数为NULL，那么调用该函数就相当于调用malloc(size)。</li>
<li>如果size参数为0，并且ptr参数不为NULL,那么调用该函数就相当于调用free(ptr)。</li>
<li>除非ptr参数为NULL,否则，ptr的值必须由先前调用malloc、calloc或realloc函数返回。</li>
</ul>
<p>编写一个程序，不断地接收用户输入的整数，直到用户输入-1表示输入结束，将所有数据打印出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;    <span class="comment">//此处必须初始化为NULL，因为realloc()参数中要求了！如前述注意事项最后一点！</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input number(-1: exit):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        count++;</span><br><span class="line">        ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr,count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        ptr[count<span class="number">-1</span>] = num;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论是malloc、calloc还是realloc函数，都需要搭配free函数释放内存！</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="顺序读写文件"><a href="#顺序读写文件" class="headerlink" title="顺序读写文件"></a>顺序读写文件</h3><p>本节主要练习那些文件操作函数，见传送门-&gt;<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-66397-1-1.html">C语言函数索引</a><br>常用的，例如：</p>
<ul>
<li>fopen();</li>
<li>fputc()/putc();  (区别于putchar，看着很像)</li>
<li>fgetc()/getc(); （区别于getchar()）</li>
<li>fputs();</li>
<li>fgets();</li>
</ul>
<p>这一节还有几个比较有趣的拓展阅读:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-91062-1-2.html">如何理解万物皆文件</a></li>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-92251-1-2.html">文本流与二进制流的区别</a></li>
</ul>
</article><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/Resource%20sharing/01%E5%9C%9F%E6%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><img class="prev-cover" src="https://ooo.0x0.ooo/2024/01/04/OZaA3S.jpg" onerror="onerror=null;src='/source/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">土木工程专业课程设计</div></div></a></div><div class="next-post pull-right"><a href="/2023/Specific%20subject/01%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/"><img class="next-cover" src="https://ooo.0x0.ooo/2024/01/04/OZaZiN.webp" onerror="onerror=null;src='/source/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">大端与小端</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="https://ooo.0x0.ooo/2024/01/02/OKuyvU.jpg" onerror="this.onerror=null;this.src='/source/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);"><b style="color:#fff">欢迎访问本站！<br>本站主要分享自己求学路上的一些心得！<br>本站依托于GitHub服务器，推荐科学上网浏览！</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Charm_Hu</h1><div class="author-info__desc">生活明朗, 万物可爱！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Hushuangjun" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/691881848?spm_id_from=333.1007.0.0" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><img src="https://api.hanximeng.com/ip_sign/"/></div></div><!-- 下列为源代码--><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">选择结构程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">循环结构程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.1.</span> <span class="toc-text">数组定义及初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">1.4.2.</span> <span class="toc-text">字符串输入与输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">字符串处理函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.5.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">指针与指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">一维数组与指针的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.3.</span> <span class="toc-text">指针与数组的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">1.5.4.</span> <span class="toc-text">指针数组和数组指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.5.</span> <span class="toc-text">指针与二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E6%8C%87%E9%92%88%E4%B8%8ENULL%E6%8C%87%E9%92%88"><span class="toc-number">1.5.6.</span> <span class="toc-text">void指针与NULL指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.5.7.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.8.</span> <span class="toc-text">指向指针的指针与二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.5.9.</span> <span class="toc-text">常量和指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">1.6.1.</span> <span class="toc-text">函数初体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">参数和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.6.3.</span> <span class="toc-text">指针函数与函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">局部变量与全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.5.</span> <span class="toc-text">作用域与链接属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">链接属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.6.</span> <span class="toc-text">生存期与存储类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">生存期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">存储类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.6.7.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.8.</span> <span class="toc-text">动态内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">malloc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">free函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.6.8.3.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E4%BB%BB%E6%84%8F%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.6.8.4.</span> <span class="toc-text">申请任意尺寸的内存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#calloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.8.5.</span> <span class="toc-text">calloc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#realloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.8.6.</span> <span class="toc-text">realloc函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">顺序读写文件</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/Resource%20sharing/02%E8%8B%B1%E8%AF%AD%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0/" title="英语音标与自然拼读"><img src="https://ooo.0x0.ooo/2024/04/14/OmYotG.jpg" onerror="this.onerror=null;this.src='/source/img/404.jpg'" alt="英语音标与自然拼读"/></a><div class="content"><a class="title" href="/2024/Resource%20sharing/02%E8%8B%B1%E8%AF%AD%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0/" title="英语音标与自然拼读">英语音标与自然拼读</a><time datetime="2024-04-13T16:00:00.000Z" title="发表于 2024-04-14 00:00:00">2024-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/Specific%20subject/07BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="BP神经网络"><img src="https://ooo.0x0.ooo/2024/04/14/OmYkrP.png" onerror="this.onerror=null;this.src='/source/img/404.jpg'" alt="BP神经网络"/></a><div class="content"><a class="title" href="/2024/Specific%20subject/07BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="BP神经网络">BP神经网络</a><time datetime="2024-04-13T16:00:00.000Z" title="发表于 2024-04-14 00:00:00">2024-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/Useful%20tools/02%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/" title="科研绘图"><img src="https://ooo.0x0.ooo/2024/04/14/OmYxQb.png" onerror="this.onerror=null;this.src='/source/img/404.jpg'" alt="科研绘图"/></a><div class="content"><a class="title" href="/2024/Useful%20tools/02%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/" title="科研绘图">科研绘图</a><time datetime="2024-04-06T08:38:00.277Z" title="发表于 2024-04-06 16:38:00">2024-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/Specific%20subject/06Kriging%E6%A8%A1%E5%9E%8B%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/" title="Kriging 模型（新手福利，超详细！）"><img src="https://s2.loli.net/2024/03/17/uN246PmAaCot9nq.png" onerror="this.onerror=null;this.src='/source/img/404.jpg'" alt="Kriging 模型（新手福利，超详细！）"/></a><div class="content"><a class="title" href="/2024/Specific%20subject/06Kriging%E6%A8%A1%E5%9E%8B%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/" title="Kriging 模型（新手福利，超详细！）">Kriging 模型（新手福利，超详细！）</a><time datetime="2024-03-16T16:00:00.000Z" title="发表于 2024-03-17 00:00:00">2024-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/Useful%20tools/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/" title="提高搜索效率的小技巧"><img src="https://ooo.0x0.ooo/2024/02/17/OyMIlc.jpg" onerror="this.onerror=null;this.src='/source/img/404.jpg'" alt="提高搜索效率的小技巧"/></a><div class="content"><a class="title" href="/2024/Useful%20tools/01%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/" title="提高搜索效率的小技巧">提高搜索效率的小技巧</a><time datetime="2024-02-17T11:22:40.678Z" title="发表于 2024-02-17 19:22:40">2024-02-17</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2024 By <a class="footer-bar-link" href="/" title="Charm_Hu" target="_blank">Charm_Hu</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.husj0711.top/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9246893035&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/Kriging%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">Kriging模型<sup>1</sup></a><a href="/tags/%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95/" style="font-size: 0.88rem;">中心差分法<sup>1</sup></a><a href="/tags/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">力学基础与专业基础<sup>1</sup></a><a href="/tags/%E5%8D%95%E8%AF%8D%E6%8B%BC%E8%AF%BB/" style="font-size: 0.88rem;">单词拼读<sup>1</sup></a><a href="/tags/%E6%8C%AF%E5%9E%8B%E5%88%86%E8%A7%A3%E5%8F%8D%E5%BA%94%E8%B0%B1%E6%B3%95/" style="font-size: 0.88rem;">振型分解反应谱法<sup>1</sup></a><a href="/tags/%E6%A3%80%E7%B4%A2%E8%B5%84%E6%96%99/" style="font-size: 0.88rem;">检索资料<sup>1</sup></a><a href="/tags/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/" style="font-size: 0.88rem;">毕业论文<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 0.88rem;">生活<sup>1</sup></a><a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">神经网络<sup>1</sup></a><a href="/tags/%E7%A7%91%E7%A0%94%E7%BB%98%E5%9B%BE/" style="font-size: 0.88rem;">科研绘图<sup>1</sup></a><a href="/tags/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">结构设计杂谈<sup>1</sup></a><a href="/tags/%E9%9F%B3%E6%A0%87/" style="font-size: 0.88rem;">音标<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("07/24/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Charm_Hu 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initWaline = () => {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://comment.husj0711.top',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const loadWaline = async () => {
    if (typeof Waline === 'object') initWaline()
    else {
      await getCSS('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.css')
      await getScript('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.js')
      initWaline()
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('https://comment.husj0711.top/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 5/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>