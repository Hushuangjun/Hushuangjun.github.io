<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本科毕业论文进展记录</title>
      <link href="/2024/Life/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%BF%9B%E5%B1%95/"/>
      <url>/2024/Life/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%BF%9B%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>记录毕业论文进展，监督自己，共勉之！</p></div><h3 id="2024-1-17记录"><a href="#2024-1-17记录" class="headerlink" title="2024-1-17记录"></a>2024-1-17记录</h3><p>今天老师开了一次组会，大致讲了一下接下来安排，时间要抓紧啦。自从上次卡在自己给自己设的坑那里，就没动过了。最近一个月都在忙复习，主要是钢结构设计。只能说有舍有得吧，感觉经过钢结构设计，自己能力又得到进一步提升。随着期末接近尾声，还差最后一门高英，加油！</p><ul><li>在系统中上传了一次周进展；</li><li>完成了英文文献摘要部分的翻译；</li></ul><h3 id="2024-1-18记录："><a href="#2024-1-18记录：" class="headerlink" title="2024-1-18记录："></a>2024-1-18记录：</h3><p>Done：</p><ul><li>完成了英文文献引言部分的翻译。PS: 果然，老外写的句子跟咱们中国人写的句子不太一样，感觉说话断断续续的，难翻的要命😔。</li></ul><p>估计要断更一两天了，明天就要考最后一门啦，考完就要收拾东西回家了，一天都得奔走在路上，加油加油！</p><h3 id="2024-1-19记录："><a href="#2024-1-19记录：" class="headerlink" title="2024-1-19记录："></a>2024-1-19记录：</h3><p>考完最后一门了，回家回家！<br>Done:</p><ul><li>文献翻译到有限元分析了，今晚再努把力，明天祈祷火车上能把翻译工作推进一下，或者看看CST方法，得加快进度了。</li></ul><h3 id="2024-1-21记录："><a href="#2024-1-21记录：" class="headerlink" title="2024-1-21记录："></a>2024-1-21记录：</h3><p>今天终于回到家了！！！<br>在火车上复习了CST方法，顺便把要翻译的文献通了一遍。<br>Done:</p><ul><li>完成了文献翻译。</li></ul><h3 id="2024-1-22记录："><a href="#2024-1-22记录：" class="headerlink" title="2024-1-22记录："></a>2024-1-22记录：</h3><p>Done: </p><ul><li>今天回顾了穿孔钢梁的一些设计方法！！！</li></ul><p>Plan:</p><ul><li>明天一定要验算以下模型了，不能再停滞不前了！！！</li></ul><h3 id="2024-1-23记录："><a href="#2024-1-23记录：" class="headerlink" title="2024-1-23记录："></a>2024-1-23记录：</h3><p>Done:</p><ul><li>弄清楚了ANSYS WB中如何将实体单元转化为壳单元。明天就可以开始验算论文内容了！！！</li></ul><h3 id="2024-1-24记录："><a href="#2024-1-24记录：" class="headerlink" title="2024-1-24记录："></a>2024-1-24记录：</h3><p>Done:</p><ul><li>学会了穿孔钢梁运用shell 181建模；</li><li>上传了一次周进展；</li></ul><h3 id="2024-1-25记录："><a href="#2024-1-25记录：" class="headerlink" title="2024-1-25记录："></a>2024-1-25记录：</h3><p>Done:</p><ul><li>今天完成了特征值屈曲分析，终于可以试验设计了！！！</li></ul><p>明天得争取开始用C语言编程了！！！</p><h3 id="2024-1-29记录："><a href="#2024-1-29记录：" class="headerlink" title="2024-1-29记录："></a>2024-1-29记录：</h3><p>Done:</p><ul><li>完成了C语言编程生成CAD命令流，现在只需要更改文件里的参数，就可以自动生成相应的三维孔洞形状CAD命令流啦。</li><li>借助上述命令流完成一个孔洞形状建模，并导入ANSYS WB中，惊奇地发现，每次只要更改导入的孔洞形状文件(.sat)，就可以生成对应的穿孔钢梁几何模型啦，太酷啦！！！</li><li>初步采用拉丁超立方采样，多项式拟合得到响应面！！！因为现在自己只会Design Expert软件，先用多项式拟合看看，精度不行增加样本点即可。等后面有空了再考虑Kriging等方法来拟合！！！</li></ul><h3 id="2024-2-1记录："><a href="#2024-2-1记录：" class="headerlink" title="2024-2-1记录："></a>2024-2-1记录：</h3><p>Done:</p><ul><li>完成了15组（有两组存在尺寸干涉）试验仿真，然后代入design expert软件中，进行多项式拟合；结果还不错，各项指标还可以，并验证了两者，误差还行。但对于ANSYS WB跑出来的结果，我是有点疑问的，因为感觉孔开的越大，临界屈曲荷载越大，也有可能是自己还未了解特征值屈曲分析，下阶段可以了解了解！！！</li><li>上传了一次周进展；</li></ul><h3 id="2024-2-7记录："><a href="#2024-2-7记录：" class="headerlink" title="2024-2-7记录："></a>2024-2-7记录：</h3><p>快过年啦，这些天忙于其他事，毕业论文小小耽搁一下嘿嘿🤭！</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>振型分解反应谱法及相关系数推导</title>
      <link href="/2024/Specific%20subject/05%E6%8C%AF%E5%9E%8B%E5%88%86%E8%A7%A3%E5%8F%8D%E5%BA%94%E8%B0%B1%E6%B3%95%E6%8E%A8%E5%AF%BC/"/>
      <url>/2024/Specific%20subject/05%E6%8C%AF%E5%9E%8B%E5%88%86%E8%A7%A3%E5%8F%8D%E5%BA%94%E8%B0%B1%E6%B3%95%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>整理自<a href="https://www.husj0711.top/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/">结构设计杂谈</a>. 理解本文需要阅读一下上述链接中资料或本身具有一定基础！<br>振型分解反应谱只适用于<strong>弹性分析</strong>。</p><p>下面开始正式推导！</p><h1 id="振型分解法"><a href="#振型分解法" class="headerlink" title="振型分解法"></a>振型分解法</h1><p><img src="/2024/Specific%20subject/05%E6%8C%AF%E5%9E%8B%E5%88%86%E8%A7%A3%E5%8F%8D%E5%BA%94%E8%B0%B1%E6%B3%95%E6%8E%A8%E5%AF%BC/地震动等效动荷载.jpg" alt="计算简图"><br>易知多自由度(这里设为n)结构体系在地震动作用下运动微分方程为:</p><script type="math/tex; mode=display">\tag{1} M\ddot X + C\dot X + KX =  - M\{ 1\} {\ddot x_g}</script><p>易知该结构体系无阻尼自由振动微分方程为$M\ddot X + KX = 0$，由高等数学知识可知，其解为$X = \varphi \sin \left( {wt} \right)$，再代入无阻尼自由振动微分方程中，由于$\omega  \ne 0$，$\varphi \ne {0}$，即得:</p><script type="math/tex; mode=display">\tag{2}- {\omega ^2}{M\varphi } + {K\varphi } = {0}</script><p>也即：</p><script type="math/tex; mode=display">{M}^{ - 1}{K\varphi }{\text{ = }}{\omega ^2}{\varphi }</script><p>由线性代数知识知，这等效于求${M^{ - 1}}K$的特征值和特征向量。于是解特征方程:</p><script type="math/tex; mode=display">\tag{3}\left| {K - {\omega ^2}M} \right| = 0</script><p>由于结构刚度矩阵K是正定的，一定能得到<strong>n个正特征值(允许有重根)和n个线性无关的特征向量</strong>！</p><blockquote><p>为啥能得到？见开头所讲资料；</p></blockquote><p>而且对于任意两个不同频率($\omega_{i}$、$\omega_{j}$)所对应的振型向量($\varphi_{i}$、$\varphi_{j}$)关于质量矩阵M、阻尼矩阵C和刚度矩阵K是正交的！</p><blockquote><p>事实上，对于重根的情况，也可以找到两个振型关于上述矩阵正交。具体原理可参加《结构动力学》（Chopra 著）。</p></blockquote><p>下面以质量矩阵M为例：<br>将$\varphi _i$和$\varphi _j$代入式(1)中，得：</p><script type="math/tex; mode=display">\tag{4}- w_i^2M{\varphi _i} + K{\varphi _i} = 0</script><script type="math/tex; mode=display">\tag{5}- w_j^2M{\varphi _j} + K{\varphi _j} = 0</script><p>将式(4)等式两边同乘以$\varphi _j^T$，式(5)等式两边同乘$\varphi _i^T$，并等式两边同时转置，有:</p><script type="math/tex; mode=display">\tag{6} - \omega _i^2\varphi _j^TM{\varphi _i} + \varphi _j^TK{\varphi _i} = 0</script><script type="math/tex; mode=display">\tag{7} - \omega _j^2\varphi _j^TM{\varphi _i} + \varphi _j^TK{\varphi _i} = 0</script><blockquote><p>M、K由于是对称矩阵，其转置等于自身。</p></blockquote><p>式(6)-式(7)，得到：</p><script type="math/tex; mode=display">\left( {\omega _j^2 - \omega _i^2} \right)\varphi _j^TM{\varphi _i} = 0</script><p>由于$\omega_{i} \ne \omega_{j}$，则有</p><script type="math/tex; mode=display">\varphi _j^TM\varphi _i = 0</script><p>得证！</p><p>由于n个特征向量线性无关，故可作为一组基来表示结构的位移，即$X = \sum {({q_i(t)}{\varphi _i})} $，t表示第t时刻，将X表达式代入式(1)，有：<br>$$ M\{ \sum {\left( {{{\ddot q}_i}{\varphi _i}} \right)} \}  + C\{ \sum {\left( {{{\dot q}_i}{\varphi _i}} \right)} \}  + K\{ \sum {\left( {{q_i}{\varphi _i}} \right)} \}  =  - M\{ 1\} {\ddot x_g} $$</p><p>上式等式两边同左乘$\varphi _i^T$，根据振型向量的正交性，有：</p><script type="math/tex; mode=display">\varphi _i^TM{\ddot q_i}{\varphi _i} + \varphi _i^TC{\dot q_i}{\varphi _i} + \varphi _i^TK{q_i}{\varphi _i} =  - \varphi _i^TM\{ 1\} {\ddot x_g}</script><p>也即：</p><script type="math/tex; mode=display">\tag{8} \varphi _i^TM{\varphi _i}{\ddot q_i} + \varphi _i^TC{\varphi _i}{\dot q_i} + \varphi _i^TK{\varphi _i}{q_i} =  - \varphi _i^TM\{ 1\} {\ddot x_g}</script><p>记${M_i} = \varphi _i^TM{\varphi _i},{C_i} = \varphi _i^TC{\varphi _i},{K_i} = \varphi _i^TK{\varphi _i}{q_i}$，分别称为<strong>第i阶振型的广义质量、阻尼和刚度矩阵</strong>。</p><p>于是就有：</p><script type="math/tex; mode=display">\tag{9} {M_i}{\ddot q_i} + {C_i}{\dot q_i} + {K_i}{q_i} =  - \varphi _i^TM\{ 1\} {\ddot x_g}</script><p>式(9)还可以表示为：<br>$$ {M_i}{\ddot q_i} + {C_i}{\dot q_i} + {K_i}{q_i} =  - \frac{{\varphi _i^TM\{ 1\} }}{M_i}{M_i}{\ddot x_g}$$</p><p>现记${\gamma _i} = \frac{ {\varphi _i^TM\{ 1\} } }{ { {M_i} } } = \frac{ {\varphi _i^TM\{ 1\} } }{ {\varphi _i^TM{\varphi _i} } }$，称为<strong>第i阶振型的振型参与系数</strong>。</p><p>易知振型参与系数满足如下关系：</p><script type="math/tex; mode=display">\tag{10} \sum {\left( { {\gamma _i}{\varphi _i} } \right) = \{ 1\} }</script><p>证明如下：<br>式(10)等式两端同左乘${\varphi _i}^TM$，根据振型的正交性，有：</p><script type="math/tex; mode=display">{\gamma _i}\varphi _i^TM{\varphi _i} = \varphi _i^TM\{ 1\}</script><p>由此，显然有：</p><script type="math/tex; mode=display">{\gamma _i} = \frac{ {\varphi _i^TM\{ 1\} } }{ {\varphi _i^TM{\varphi _i} } }</script><p>得证！</p><p>令 ${D_i} = \frac{q_i}{\gamma _i}$，记为第i阶振型的地震响应时程。<br>于是式(9)就转化为：</p><script type="math/tex; mode=display">{M_i}{\ddot D_i} + {C_i}{\dot D_i} + {K_i}{D_i} =  - {M_i}{\ddot x_g}</script><p>从上式可以看出，第i振型的振动满足单自由度结构体系受迫振动运动微分方程。<br>对于给定的地震动时程，可以利用求解单自由度体系方法获得第i振型的地震响应时程$D_i$。由于i的任意性，可以看出在t时刻，多自由度结构体系各振型均满足单自由度结构体系受迫振动运动微分方程。通过振型叠加，即可获得各自由度的位移相对时程：</p><script type="math/tex; mode=display">X = \sum\limits_{i = 1}^n {\left( { {D_i}{\gamma _i}{\varphi _i} } \right)}</script><p>这种利用<strong>振型的正交性</strong>，将多自由度结构体系振动解耦成单自由度结构体系振动的方法称为<strong>振型分解法</strong>！</p><h1 id="振型分解反应谱法"><a href="#振型分解反应谱法" class="headerlink" title="振型分解反应谱法"></a>振型分解反应谱法</h1><p>在前述基础上，引入反应谱的概念。<br>常用的反应谱包括<strong>加速度反应谱和位移反应谱(亦称伪加速度反应谱)</strong>，下面以位移谱为例进行推导。<br>位移谱定义：<br>$$\alpha  = \frac{{{K_i}{D_{i\_\max }}\left( T \right)}}{{{M_i}g}}$$</p><p>对于第i阶振型，其地震响应时程最大值的标准值为:<br>$${D_{i\_k}} = \frac{{{\alpha _i}{M_i}g}}{{{K_i}}} = \frac{{{\alpha _i}g}}{{\omega _i^2}}$$</p><p>则第i振型最大位移为：</p><script type="math/tex; mode=display">{X_i} = {D_{i\_k}}{\gamma _i}{\varphi _i}</script><blockquote><p>因为${\gamma _i}{\varphi _i}$是定值，$D_{i}$取最大，即$X_i$取最大。</p></blockquote><p>我们认为结构处于最大位移时最不利，相应的地震作用为：<br>$$\begin{align*}F_i &= KX_i = KD_{i\_k}\gamma_i\varphi_i = K\frac{\alpha_ig}{\omega_i^2}\gamma_i\varphi_i = \frac{\alpha_ig}{\omega_i^2}\gamma_iMM^{-1}K\varphi_i \\    &= \frac{\alpha_ig}{\omega_i^2}\gamma_iM\omega_i^2\varphi_i \\    &= \tag{11}\alpha_i\gamma_igM\varphi_i\end{align*}$$</p><p>这样，我们就得到了第i阶振型所对应的地震作用啦！<br>对于第j个质点，其所受地震作用为：</p><script type="math/tex; mode=display">\tag{12}{F_{i,j} } = {\alpha _i}{\gamma _i}g{m_j}{\varphi _{i,j} }</script><p><strong>作用效应组合</strong>：采用平方和开平方法(SRSS法)</p><script type="math/tex; mode=display">\sqrt {\sum\limits_{i = 1}^n {\left( {S_i^2} \right)} }</script><h1 id="振型参与质量系数与振型有效质量系数"><a href="#振型参与质量系数与振型有效质量系数" class="headerlink" title="振型参与质量系数与振型有效质量系数"></a>振型参与质量系数与振型有效质量系数</h1><p>疑惑起源：<br>《抗规》中提到，振型个数一般需要取振型参与质量累计达到总质量90%所需的振型数。</p><p>第i阶振型的地震作用：</p><script type="math/tex; mode=display">F_i = \alpha_i\gamma_igM\varphi_i</script><p>上式可以写成：<br>$${F_i} = {\alpha _i}{\gamma _i}Mg{\varphi _i} = \frac{{{\alpha _i}g}}{{\ddot x}_{g\_\max }}M{\ddot x_{g\_\max }}{\gamma _i}{\varphi _i}$$<br>这里我们称 $\frac{ { {\alpha _i}g} }{ { { {\ddot x}_{g_\max } } } }$ 为动力放大系数，记为$\beta$，即：</p><script type="math/tex; mode=display">\beta = \frac{ { {\alpha _i}g} }{ { { {\ddot x}_{g\_\max } } } }</script><p>其中$M{\ddot x_{g_\max }}{\gamma _i}{\varphi _i}$为<strong>地震动最大加速度的等效动荷载在第i阶振型上的分量</strong>。</p><p>则$F_i$产生的效应可以写成：<br>$${S_i} = S\left( {{F_i}} \right) = \beta S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)$$<br>可见，地震动最大加速度的等效动荷载在第i阶振型上的分量引起的结构响应越大，地震响应系数$\alpha_{i}$越大，则第i振型对应的效应就越大.</p><p>对于线弹性体系，有：<br>$$S\left( {M\{ 1\} {{\ddot x}_{g\_\max }}} \right) = S\left( {M\sum {\left( {{\gamma _i}{\varphi _i}} \right){{\ddot x}_{g\_\max }}} } \right) = \sum {\left( {S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)} \right)}$$</p><p>令<br>$${\mu _{S\_j}} = \frac{{\sum\limits_{i = 1}^j {\left( {S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)} \right)} }}{{\sum\limits_{i = 1}^n {\left( {S\left( {M{{\ddot x}_{g\_\max }}{\gamma _i}{\varphi _i}} \right)} \right)} }}$$<br>称$\mu_{S_j}$为<strong>效应S的振型有效质量系数。</strong></p><p>一般来讲，结构的<strong>基底剪力(首层剪力)</strong>能够很好地反映结构的整体响应。<br>式(12)为第i阶振型第j个质点所受地震水平力，则基底剪力可以表示为：</p><p>易知基底剪力可以表示为：</p><script type="math/tex; mode=display">{F_{BS}} = {\{ 1\} ^T}{\alpha _i}{\gamma _i}Mg{\varphi _i}</script><p>则基底剪力的振型有效质量系数$\mu _{BS_j}$为:<br>$$\begin{align*}{\mu _{BS\_j}} &= \frac{{\sum\limits_{i = 1}^j {\left( {{{\{ 1\} }^T}{\alpha _i}{\gamma _i}Mg{\varphi _i}} \right)} }}{{\sum\limits_{i = 1}^n {\left( {{{\{ 1\} }^T}{\alpha _i}{\gamma _i}Mg{\varphi _i}} \right)} }} = \frac{{\sum\limits_{i = 1}^j {\left( {{{\{ 1\} }^T}{\gamma _i}M{\varphi _i}} \right)} }}{{{{\{ 1\} }^T}M\sum\limits_{i = 1}^n {\left( {{\gamma _i}{\varphi _i}} \right)} }} = \frac{{\sum\limits_{i = 1}^j {\left( {{{\{ \sum {{\gamma _i}{\varphi _i}} \} }^T}{\gamma _i}M{\varphi _i}} \right)} }}{{{{\{ 1\} }^T}M\{ 1\} }} \\   &= \frac{{\sum\limits_{i = 1}^j {\left( {{\gamma _i}\varphi _i^T{\gamma _i}M{\varphi _i}} \right)} }}{{\sum\limits_{i = 1}^n {{m_i}} }}\\    &= \frac{{\sum\limits_{i = 1}^j {\left( {\gamma _i^2{M_i}} \right)} }}{{\sum\limits_{i = 1}^n {{m_i}} }}\end{align*}$$</p><p>进一步，令</p><script type="math/tex; mode=display">M_i^* = \gamma _i^2{M_i}</script><p>称$M_i^*$为第i阶振型的基底剪力振型参与质量。</p><p>自然而言，有<strong>第i阶振型的基底剪力振型参与质量系数</strong>:</p><script type="math/tex; mode=display">\mu_{i} = \frac{ {M_i^*} }{ {\sum\limits_{i = 1}^n { {m_i} } } }</script><p>易知其满足：</p><script type="math/tex; mode=display">\sum\limits_{i = 1}^n { {\mu _i} }  = 1</script><p>如前述所说，结构的基底剪力能够很好地反映结构的整体响应，所以我们一般就采用基底剪力振型参与质量系数和基底剪力有效质量系数，并简称<strong>振型参与质量系数与振型有效质量系数</strong>！</p><p>先写到这吧，还挺多的呢，敬请期待(☆▽☆)</p>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 振型分解反应谱法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程造价计算题</title>
      <link href="/2024/Specific%20subject/04%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7%E8%AE%A1%E7%AE%97%E9%A2%98/"/>
      <url>/2024/Specific%20subject/04%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7%E8%AE%A1%E7%AE%97%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="tip warning"><p>需要注意的是，本文所提供的下载链接只保持三天！！！过期如有需要可在下方或者在<code>友链-&gt;留言板</code>处留言！</p></div><div class="tip warning"><p>如果pdf未显示，刷新一下即可！(●ˇ∀ˇ●)</p></div><p>考试题型：</p><ol><li>选择题(2/20),共计40分.<br>考察概念和简单计算，包括但不限于：进口设备购置费、定额原理、劳动单价、预备费和建设期贷款利息等等。</li><li>判断对错题, 10分.</li><li>计算题<br>综合单价一道(10分)，工程结算一道(30分)。 </li><li>综合分析题(类似于论述题)，考察对这门课的认识。(10分)<br>估计是老师捞人的，加油加油！😊</li></ol><p>所有PPT中<strong>第8讲、第9讲PPT</strong>可以不用看。<br>给刚复习的人的福利(●ˇ∀ˇ●)—&gt;<a href="http://qny.husj0711.top/pdf/%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7-%E5%BB%BA%E8%AE%BE%E5%B7%A5%E8%B5%84.pdf?e=1704990745&amp;token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:j6X1gyBHKNKiu7dqFz6vmt9vBNk=">点击开始下载</a></p><p>奥里给！！<br>下面为PPT上没有答案的例题：</p><h1 id="第2讲工程项目投资构成1"><a href="#第2讲工程项目投资构成1" class="headerlink" title="第2讲工程项目投资构成1"></a>第2讲工程项目投资构成1</h1><div class="row">    <embed src="第2讲工程项目投资构成1.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第3讲工程项目投资构成2"><a href="#第3讲工程项目投资构成2" class="headerlink" title="第3讲工程项目投资构成2"></a>第3讲工程项目投资构成2</h1><div class="row">    <embed src="第3讲工程项目投资构成2.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第4讲工程项目投资构成3"><a href="#第4讲工程项目投资构成3" class="headerlink" title="第4讲工程项目投资构成3"></a>第4讲工程项目投资构成3</h1><p>涨价预备费计算公式：</p><script type="math/tex; mode=display">涨价预备费= \sum I _ { t } [ ( 1 + f ) ^ { t } - 1 ]</script><p>式中t为第t年，f为价格上涨率, $I_{t}$表示第t年的静态投资。</p><div class="row">    <embed src="第4讲工程项目投资构成3.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第5讲建筑工程定额原理1"><a href="#第5讲建筑工程定额原理1" class="headerlink" title="第5讲建筑工程定额原理1"></a>第5讲建筑工程定额原理1</h1><p>注意：<strong>残值率==回收折价率</strong>！<br>下面PDF中有问题，考试肯定直接给回收折价率，套公式即可！<br><div class="row">    <embed src="第5讲建筑工程定额原理1.pdf" width="100%" height="550" type="application/pdf"></div></p><h1 id="第7讲工程量及其计算规则1"><a href="#第7讲工程量及其计算规则1" class="headerlink" title="第7讲工程量及其计算规则1"></a>第7讲工程量及其计算规则1</h1><p>这里需要自己看看<code>清单计价规范</code>和<code>定额计价规范</code>才好理解，规范下载在BB平台上。<br>第8讲PPT老师没有讲，可以略过。<br>第9讲广联达计算也可以略过。</p><div class="row">    <embed src="第7讲工程量及其计算规则1.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="第15讲工程结算"><a href="#第15讲工程结算" class="headerlink" title="第15讲工程结算"></a>第15讲工程结算</h1><p><strong>这个题目非常重要，占30分</strong>！！！<br>每期工程结算款就按下述公式来：</p><div align="center"><img src="/2024/Specific%20subject/04%E5%B7%A5%E7%A8%8B%E4%BC%B0%E4%BB%B7%E8%AE%A1%E7%AE%97%E9%A2%98/工程款结算.jpg" width="90%"></div><hr><div class="row">    <embed src="第15讲工程结算.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>钢结构设计作业（海大）</title>
      <link href="/2024/Specific%20subject/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/2024/Specific%20subject/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>需要注意的是，本文所提供的下载链接只保持三天！！！过期如有需要可在下方或者在<code>友链-&gt;留言板</code>处留言！</p></div><div class="tip warning"><p>如果pdf未显示，刷新一下即可！(●ˇ∀ˇ●)</p></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>建议：<strong>务必把上个学期卷子弄懂！</strong>    <a href="http://qny.husj0711.top/%E9%92%A2%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7.zip?e=1704990717&amp;token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:eLxXIfMn4TbthvFmpiNhptpEyr4=">点击开始下载试卷和答案</a>.</p><p>由于选择、判断没有详细解释，现把每题对应PPT分析如下：</p><details class="folding-tag" yellow><summary> 点击展开 </summary>              <div class="content">              <p><strong>选择题：</strong></p><blockquote><p>Chap 1代表第一章PPT，以此类推。Chap 4指《04-2多高层钢结构》，《04-1高层结构地震分析》会单独指出。</p></blockquote><ol><li>Chap 2; P37;</li><li>Chap 1; P9;</li><li>Chap 1; P11;</li><li>《混凝土结构中册》; P11;</li><li>Chap 4; P84;</li><li>Chap 2; P12;</li><li>Chap 3; P105;</li><li>Chap 3; P142;</li><li>Chap 3; P65;</li><li>Chap 4; P5;</li></ol><p><strong>判断题:</strong></p><ol><li>摇摆柱定义见《钢结构上册》第五章； P156; 摇摆柱上下都是铰接节点，当然不能提供抗侧力呀！</li><li>Chap 1; P19;</li><li>《04-1 高层结构地震分析》； P3;  如果不好理解，建议看《建筑结构抗震》振型分解反应谱法推导过程，相对好理解;</li><li>Chap 1; P25;</li><li>Chap 2；P11;</li><li>Chap 2; P51;</li><li>Chap 3; P77;</li><li>Chap 3; P110; 从曲线得出是跃越失稳；还不明白啥是极值点失稳、分支点失稳和跃越失稳？详见《钢结构上册》P72；</li><li>Chap 4; P7;</li><li>Chap 4; P91; </li></ol>              </div>            </details><p>最后两个大题，目前意思是<code>第三章课上小测</code>和<code>第二章加强上翼缘吊车梁强度验算</code>，先把这两个题牢牢掌握。但第三章课上小测相比去年那个题目难度下降太多，小心有坑！而且第二章吊车梁，老师说今年会出稍微难点，可能会出<code>制动梁或者制动桁架</code>。注意，不要被求解弯矩M/剪力V复杂代码吓着，考试肯定会给出内力的，重点在<code>截面特性计算</code>和<code>强度验算</code>。拿下大题及格应该不难！</p><p>下面是老师上课暗示过必考或者很可能考的内容，尽量弄懂:<br><details class="folding-tag" yellow><summary> 点击展开 </summary>              <div class="content">              <ol><li>风振系数$\beta_{z}$和阵风系数$\beta_{gz}$适用对象；<br>风振系数是计算主体结构的，阵风系数是计算维护结构的。</li><li>高层建筑在水平荷载作用下位移曲线呈剪切型和弯曲型，主要由于啥变形造成的？<br>剪切型是由于梁、柱弯曲变形造成的，弯曲型主要是柱轴向变形造成的。</li><li>抗震设计的<code>三水准两阶段</code><br>详见第四章PPT34、35页。</li><li>S1-S5级截面的含义，在轻型门式刚架刚架梁、柱翼缘和腹板的截面分类属于哪一类？<br>截面分类请参考《钢结构设计标准》条文说明第3.5.1条。<br>翼缘按S4级截面设计，腹板按S5级截面设计。</li><li>索结构索形状的确定，当荷载沿跨度和沿索长，对应形状是啥？<br>沿跨度是抛物线，沿索长是悬链线。<blockquote><p>学有余力的同学建议看看此处公式推导，大题第一道有可能会考！</p></blockquote></li><li>承载力抗震调整系数$\gamma_{RE}$小于1的原因？<br>见第四章PPT第60页。</li></ol>              </div>            </details></p><p>赶快行动吧，不然会很痛苦！</p><h1 id="第一章-轻型门式刚架"><a href="#第一章-轻型门式刚架" class="headerlink" title="第一章 轻型门式刚架"></a>第一章 轻型门式刚架</h1><h2 id="课上小测"><a href="#课上小测" class="headerlink" title="课上小测"></a>课上小测</h2><p><strong>去年期末试卷倒数第二题</strong>！！如下：<br><img src="/2024/Specific%20subject/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/期末试卷倒数第二题.jpg" alt="期末试卷倒数第二题"></p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>压弯构件在弯剪共同作用下的强度验算。<br><div class="row">    <embed src="第一次作业-刚架柱验算.pdf" width="100%" height="550" type="application/pdf"></div><br>需要注意的是，由于截面只有部分有效，截面的形心和形心主轴已发生变化！形心坐标可根据以下公式求解：</p><script type="math/tex; mode=display">\overline { y } = \frac { \int y d S } { \int d S }</script><p>求解完之后，还需重新计算截面惯性矩，本质上都是依据<strong>平行移轴定理</strong>。后续截面比较复杂，可借助CAD求解截面特性，参考：<a href="https://www.zwcad.com/service_69_5076.html">CAD求解惯性矩</a>.</p><p>在第一次做的时候，很容易忽略这个点，究其根本，是对弯曲正应力公式的适用条件不太清楚。进一步，可深入了解一下广义弯曲正应力公式，后续有空来补坑。🤭<br><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap1%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A-%E5%88%9A%E6%9E%B6%E6%9F%B1%E9%AA%8C%E7%AE%97.pdf?e=1704723189&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:KrOUAs2ybutxK-DMuOmo4Ew6EvM=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div></p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><div class="row">    <embed src="第二次作业-檩条和压型钢板.pdf" width="100%" height="550" type="application/pdf"></div><ol><li>檩条计算<br>注意，最后求出有效截面后，不仅形心变了，而且形心主轴的方向也变了，此时不得不借助CAD求解形心主惯性矩，然后根据$\tan ( 2 \alpha ) = \frac { - 2 I _ { x y } } { I _ { x } - I _ { y } }$ 确定形心主惯性轴与平行于屋面得坐标系之间的夹角 $\alpha$，具体原理可详见《材料力学》。</li><li>压型钢板计算<br>此次作业注意压型钢板验算<strong>支座处腹板的局部受压承载力</strong>时，验算公式应为：<script type="math/tex; mode=display">R \leq n R _ { w }</script>式中<code>n</code>为所取压型钢板验算单元所含腹板数！也就是说，计算$R_{w}$的公式只是一块腹板的，需注意！</li></ol><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap1%20%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A-%E6%AA%A9%E6%9D%A1%E5%92%8C%E5%8E%8B%E5%9E%8B%E9%92%A2%E6%9D%BF.pdf?e=1704723326&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:3MgAj4KyqNNMzSapQ8DSiYSXasI=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div><h1 id="第二章-中、重型工业厂房"><a href="#第二章-中、重型工业厂房" class="headerlink" title="第二章 中、重型工业厂房"></a>第二章 中、重型工业厂房</h1><h2 id="第一次作业-1"><a href="#第一次作业-1" class="headerlink" title="第一次作业"></a>第一次作业</h2><div class="row">    <embed src="钢结构设计第二章作业.pdf" width="100%" height="550" type="application/pdf"></div><p>考试可能性最大的应该就是加强上翼缘的吊车梁验算(下图所示)了吧。其余两种，学有余力还是看看为好！不需要看如何求解内力M、N等，<strong>重在截面特性计算、强度验算</strong>！</p><div align="center"><img src="/2024/Specific%20subject/03%E9%92%A2%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/习题2.3.jpg" width="90%"></div><p>注意，吊车横向荷载只由制动结构(加强上翼缘、制动桁架和制动梁)承受，求解抵抗矩$W_{y}$的时候要注意！</p><p>下面也给出了计算吊车梁截面影响线的程序和源码，程序可直接运行，用户可自定义输入<code>最大轮压标准值</code>、<code>吊车各轮距</code>、<code>吊车跨度</code>等参数。有兴趣的可以考完了解了解。</p><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap2%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A.pdf?e=1704723260&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:8BVXDaygH1M9v5oBQQ0sZ428B-U=" title="下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>下载pdf</a><a class="button no-text-decoration" href="http://qny.husj0711.top/Program/%E5%90%8A%E8%BD%A6%E6%A2%81%E5%86%85%E5%8A%9B%E5%8C%85%E7%BB%9C%E5%9B%BE%E6%B1%82%E8%A7%A3.exe?e=1704560118&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:7BpSdwI7QjA3daO0DLyIwRu-RL4=" title="下载程序"><i class="anzhiyufont anzhiyu-icon-bolt"></i>下载程序</a><a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap2%20%E5%90%8A%E8%BD%A6%E6%A2%81%E5%86%85%E5%8A%9B%E5%8C%85%E7%BB%9C%E5%9B%BE%E6%B1%82%E8%A7%A3.py?e=1704554410&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:qCT6Itrutw5cd3-E4qf6uKo-jU0=" title="下载源码"><i class="anzhiyufont anzhiyu-icon-bolt"></i>下载源码</a>          </div><h1 id="第三章-大跨空间结构"><a href="#第三章-大跨空间结构" class="headerlink" title="第三章 大跨空间结构"></a>第三章 大跨空间结构</h1><h2 id="课上小测-1"><a href="#课上小测-1" class="headerlink" title="课上小测"></a>课上小测</h2><div class="row">    <embed src="课上小测证明题.pdf" width="100%" height="550" type="application/pdf"></div><p>今天老师说不考下面的平衡-几何矩阵证明题，那么这个题考的可能性比较大，但这个不会太简单了吧，相比上学期难度降低许多，<strong>小心有坑</strong>！</p><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap3%20%E8%AF%BE%E4%B8%8A%E5%B0%8F%E6%B5%8B%E8%AF%81%E6%98%8E%E9%A2%98.pdf?e=1704723283&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:LKWBa88XblOudDj4uBdNqhbD1kg=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div><h2 id="第一次作业-2"><a href="#第一次作业-2" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>第一次做的时候，看了书和一些文献，其实就是验算<strong>结构平衡-几何矩阵互伴定理</strong>，开始是按结构矩阵分析一步步来的，略显繁琐。详见<a href="https://kns.cnki.net/kcms2/article/abstract?v=RyaFSLOYMk7J8_lxgL_sRXoQCgg-nTGKRzviJBbluTdA2OHlETWTOILYh91mLjoNUg0FIMOGuRxtO2Cju-mXuSw7vpi5Ttgm2gJ6ibKCmaRT9ElfmLNR9_PlSDbnMJM8CieDFwGLcI0=&amp;uniplatform=NZKPT&amp;language=CHS">结构平衡-几何矩阵互伴定理</a>.</p><p>大家有兴趣也可以看我最开始写的，<a href="http://www.husj0711.top/2023/Study/Civil%20engineering/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/">点击此处跳转</a>,位于<code>结构力学</code>板块下！</p><p>老师上课又讲了一遍，于是最近又重新按老师的方法写了一遍，遵循的就是<strong>力系平衡，变形协调</strong>！<br><div class="row">    <embed src="第三章第一次作业（老师推荐解法）.pdf" width="100%" height="550" type="application/pdf"></div></p><div class="btns rounded grid5">            <a class="button no-text-decoration" href="http://s6bqz76rx.hd-bkt.clouddn.com/pdf/Chap3%20%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%88%E8%80%81%E5%B8%88%E6%8E%A8%E8%8D%90%E8%A7%A3%E6%B3%95%EF%BC%89.pdf?e=1704723301&token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:R5R_EBZSvwB-DmlVyJmZQiPuJK8=" title="点击下载pdf"><i class="anzhiyufont anzhiyu-icon-bolt"></i>点击下载pdf</a>          </div><h2 id="第二次作业-1"><a href="#第二次作业-1" class="headerlink" title="第二次作业"></a>第二次作业</h2><div class="row">    <embed src="第三章第二次作业.pdf" width="100%" height="550" type="application/pdf"></div><p>网架节点验算，如果给出设计内力，直接验算也是可以的，可是$\varphi$必须要查表，考的可能性也不是很大。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><div class="row">    <embed src="第三章第三次作业.pdf" width="100%" height="550" type="application/pdf"></div><p>这个考的可能性还是有的，利用虚功原理，比较简单。</p><h1 id="第四章-多、高层钢结构"><a href="#第四章-多、高层钢结构" class="headerlink" title="第四章 多、高层钢结构"></a>第四章 多、高层钢结构</h1><h2 id="第一次作业-3"><a href="#第一次作业-3" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>作业请参见文章<a href="http://www.husj0711.top/2023/Specific%20subject/02%20%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95%E6%B1%82%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%A7%BB%E6%97%B6%E7%A8%8B%E6%9B%B2%E7%BA%BF/"><strong>中心差分法求相对位移时程曲线</strong></a></p><p>考试可能性为0，可略过。</p><hr><div class="tip success"><p><strong>完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</strong></p></div><p>感谢<a href="https://coe.ouc.edu.cn/2022/0527/c9093a371372/page.htm">谭启阳老师</a>的辛勤付出！</p><p>祝大家都能体会到钢结构设计的魅力！</p>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中心差分法求相对位移时程曲线</title>
      <link href="/2023/Specific%20subject/02%20%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95%E6%B1%82%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%A7%BB%E6%97%B6%E7%A8%8B%E6%9B%B2%E7%BA%BF/"/>
      <url>/2023/Specific%20subject/02%20%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95%E6%B1%82%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%A7%BB%E6%97%B6%E7%A8%8B%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>源码依附在文章最后，读者可跳过讲解部分可直接下载。</p><h1 id="中心差分法原理"><a href="#中心差分法原理" class="headerlink" title="中心差分法原理"></a>中心差分法原理</h1><span id="more"></span><div class="row">    <embed src="时程分析-中心差分法.pdf" width="100%" height="550" type="application/pdf"></div><p>从上述资料中可以看出，以线弹性体系为例，有：</p><script type="math/tex; mode=display">\begin{equation} \label{eq1} X _ { i + 1 } = ( \frac { M } { \Delta t ^ { 2 } } + \frac { C } { 2 \Delta t } ) ^ { - 1 } \left[ - M \{1\}\ddot { X } _ { g , i } - ( \frac { M } { \Delta t ^ { 2 } } - \frac { C } { 2 \Delta t } ) X _ { i - 1 } - ( K - \frac { 2 M } { \Delta t ^ { 2 } } ) X _ { i } \right] \end{equation}</script><p>只要我们知道了第i时刻、i-1时刻结构体系的位移(严格来说叫相对位移，下同)和第i时刻地震动加速度$\ddot { X } _ { g , i }$，就可以求出第i+1时刻结构的位移。上述资料假设了第0时刻的位移、速度为0，现不妨更为普遍的设其为$X_{0}$和$\dot{X}_{0}$,则有：</p><script type="math/tex; mode=display">\begin{equation} \label{eq2}{\dot X}_0=\frac{X_1-X_{-1}}{2\Delta t}\end{equation}</script><script type="math/tex; mode=display">\begin{equation} \label{eq3}{\ddot X}_0=\frac{X_1-2X_0+X_{-1}}{\left(\Delta t\right)^2}\end{equation}</script><p>联立即得：</p><script type="math/tex; mode=display">\begin{equation} \label{eq4}X_{-1}=X_0-\frac12{\dot X}_0\Delta t+\frac12{\ddot X}_0\left(\Delta t\right)^2\end{equation}</script><p>式中${\ddot X}_0$可根据第0时刻的多自由度结构体系运动微分方程求得:</p><script type="math/tex; mode=display">\begin{equation} \label{eq5}M{\ddot X}_0+C{\dot X}_0+KX_{0}=-M\left\{1\right\}{\ddot x}_{g,0}\end{equation}</script><p>由此，启动条件便确定了，再根据(1)式递推即可。</p><p>多自由度结构体系的中心差分法的MATLAB源码如下：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x, v, a]</span> = <span class="title">MDOF_CentralDifference</span><span class="params">(m, k, c, P, x0, v0, dt, n)</span></span></span><br><span class="line">    x = <span class="built_in">zeros</span>(<span class="built_in">size</span>(m,<span class="number">1</span>), n);  <span class="comment">% 位移</span></span><br><span class="line">    v = <span class="built_in">zeros</span>(<span class="built_in">size</span>(m,<span class="number">1</span>), n);  <span class="comment">% 速度</span></span><br><span class="line">    a = <span class="built_in">zeros</span>(<span class="built_in">size</span>(m,<span class="number">1</span>), n);  <span class="comment">% 加速度</span></span><br><span class="line"></span><br><span class="line">    x(:, <span class="number">1</span>) = x0;  <span class="comment">% 设置初始位移</span></span><br><span class="line">    v(:, <span class="number">1</span>) = v0;  <span class="comment">% 设置初始速度</span></span><br><span class="line">    a(:, <span class="number">1</span>) = m\(P(:, <span class="number">1</span>) - c * v(:, <span class="number">1</span>) - k * x(:, <span class="number">1</span>));  <span class="comment">% 计算初始加速度</span></span><br><span class="line"></span><br><span class="line">    x_1 = x(:, <span class="number">1</span>) - dt .* v(:, <span class="number">1</span>) + dt^<span class="number">2</span> / <span class="number">2</span> .* a(:, <span class="number">1</span>);  <span class="comment">% 计算 X_(-1)</span></span><br><span class="line">    P_eq = <span class="built_in">zeros</span>(<span class="built_in">size</span>(m));  <span class="comment">% 初始化等效力</span></span><br><span class="line"></span><br><span class="line">    k_eq = m ./ dt^<span class="number">2</span> + c ./ (<span class="number">2</span> * dt);  <span class="comment">% 有效弹簧系数</span></span><br><span class="line">    b1 = m ./ dt^<span class="number">2</span> - c ./ (<span class="number">2</span> * dt);  <span class="comment">% 一阶阻尼项系数</span></span><br><span class="line">    b2 = k - <span class="number">2</span> .* (m ./ dt^<span class="number">2</span>);  <span class="comment">% 二阶质量项系数</span></span><br><span class="line"></span><br><span class="line">    P_eq(:, <span class="number">1</span>) = P(:, <span class="number">1</span>) - b1 * x_1 - b2 * x(:, <span class="number">1</span>);  <span class="comment">% 计算第一步的等效力</span></span><br><span class="line">    x(:, <span class="number">2</span>) = k_eq\P_eq(:, <span class="number">1</span>) ;  <span class="comment">% 计算第二步的位移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:n<span class="number">-1</span></span><br><span class="line">        P_eq(:, <span class="built_in">i</span>) = P(:, <span class="built_in">i</span>) - b1 * x(:, <span class="built_in">i</span><span class="number">-1</span>) - b2 * x(:, <span class="built_in">i</span>);  <span class="comment">% 计算等效力</span></span><br><span class="line">        x(:, <span class="built_in">i</span>+<span class="number">1</span>) = k_eq\P_eq(:, <span class="built_in">i</span>);  <span class="comment">% 计算位移</span></span><br><span class="line">        v(:, <span class="built_in">i</span>) = (x(:, <span class="built_in">i</span>+<span class="number">1</span>) - x(:, <span class="built_in">i</span><span class="number">-1</span>)) ./ (<span class="number">2</span> * dt);  <span class="comment">% 计算速度</span></span><br><span class="line">        a(:, <span class="built_in">i</span>) = (x(:, <span class="built_in">i</span>+<span class="number">1</span>) - <span class="number">2</span> * x(:, <span class="built_in">i</span>) + x(:, <span class="built_in">i</span><span class="number">-1</span>)) ./ dt^<span class="number">2</span>;  <span class="comment">% 计算加速度</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    P_eq(:, n) = P(:, n) - b1 * x(:, n<span class="number">-1</span>) - b2 * x(:, n);</span><br><span class="line">    xx = k_eq\P_eq(:, n);</span><br><span class="line">    v(:, n) = (xx - x(:, n<span class="number">-1</span>)) ./ (<span class="number">2</span> * dt);  <span class="comment">% 计算最后一步的速度</span></span><br><span class="line">    a(:, n) = (xx - <span class="number">2</span> * x(:, n) + x(:, n<span class="number">-1</span>)) ./ dt^<span class="number">2</span>;  <span class="comment">% 计算最后一步的加速度</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="/2023/Specific%20subject/02%20%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95%E6%B1%82%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%A7%BB%E6%97%B6%E7%A8%8B%E6%9B%B2%E7%BA%BF/八层框架例题.jpg" alt="八层框架例题"></p><p>已知各阶振型及周期如下图所示，<br><img src="/2023/Specific%20subject/02%20%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95%E6%B1%82%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%A7%BB%E6%97%B6%E7%A8%8B%E6%9B%B2%E7%BA%BF/各阶振型及周期.jpg" alt="各阶振型及周期"></p><p>试利用中心差分法求其在<code>ELCentro</code>波作用下的位移时程曲线。</p><hr><h2 id="结构基本信息"><a href="#结构基本信息" class="headerlink" title="结构基本信息"></a>结构基本信息</h2><p>采用国际单位制：t\N\mm\s;</p><h3 id="质量矩阵"><a href="#质量矩阵" class="headerlink" title="质量矩阵"></a>质量矩阵</h3><p>易知结构质量矩阵为对角矩阵，有:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M = <span class="built_in">diag</span>([<span class="number">120</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">110</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="刚度矩阵"><a href="#刚度矩阵" class="headerlink" title="刚度矩阵"></a>刚度矩阵</h3><p>采用层剪切模型，易知n个自由度糖葫芦串模型的刚度矩阵表达式如下所示：</p><script type="math/tex; mode=display">\begin{equation} K=\left[\begin{array}{cccccc}k_1+k_2 & -k_2 & & & & \\-k_2 & k_2+k_3 & -k_3 & & & \\& -k_3 & \cdots & & & \\& & & k_{n-2}+k_{n-1} & -k_{n-1} & \\& & & -k_{n-1} & k_{n-1}+k_n & -k_n \\& & & & -k_n & k_n\end{array}\right]\end{equation}</script><p>故生成刚度矩阵如下：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">k <span class="built_in">=</span> [<span class="number">300</span>, <span class="number">260</span>, <span class="number">260</span>, <span class="number">260</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>]*<span class="number">1000</span> ; <span class="comment">%各层层间刚度</span></span><br><span class="line">K <span class="built_in">=</span> zeros(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span>:<span class="number">7</span>       <span class="comment">%层剪切模型的刚度矩阵</span></span><br><span class="line">    K(i,i) <span class="built_in">=</span> k(i) + k(i+<span class="number">1</span>);</span><br><span class="line">    K(i+<span class="number">1</span>,i) <span class="built_in">=</span> -k(i+<span class="number">1</span>);</span><br><span class="line">    K(i,i+<span class="number">1</span>) <span class="built_in">=</span> -k(i+<span class="number">1</span>);</span><br><span class="line">end</span><br><span class="line">K(<span class="number">8</span>,<span class="number">8</span>) <span class="built_in">=</span> k(<span class="number">8</span>);</span><br></pre></td></tr></table></figure></p><h3 id="阻尼矩阵"><a href="#阻尼矩阵" class="headerlink" title="阻尼矩阵"></a>阻尼矩阵</h3><p>采用瑞利阻尼，即$C=\alpha_0M+\alpha_1K$,其中两个系数$\alpha_0$和$\alpha_1$由下式确定：</p><script type="math/tex; mode=display">\begin{equation} \alpha _ { 0 } = \frac { 2 ( \xi _ { j } \omega _ { i } - \xi _ { i } \omega _ { j } ) \omega _ { i } \omega _ { j } } { \omega _ { i } ^ { 2 } - \omega _ { j } ^ { 2 } }\end{equation}</script><script type="math/tex; mode=display">\begin{equation} \alpha _ { 1 } = \frac { 2 ( \xi _ { i } \omega _ { i } - \xi _ { i } \omega _ { i } ) } { \omega _ { i } ^ { 2 } - \omega _ { j } ^ { 2 } }\end{equation}</script><p>其中，$\omega _ { i }$，$\xi _ { i }$表示第i振型的频率和阻尼比。<br>本题采用第1、2振型的频率和阻尼比，求解得到$\alpha_0 = 0.6296$和$\alpha_1 = 0.003075$.<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C = <span class="number">0.6296</span>*M + <span class="number">0.003075</span>*K; </span><br><span class="line">xi = <span class="number">0.05</span>;  <span class="comment">%各阶振型的阻尼比</span></span><br></pre></td></tr></table></figure></p><h2 id="读取地震动加速度时程信息"><a href="#读取地震动加速度时程信息" class="headerlink" title="读取地震动加速度时程信息"></a>读取地震动加速度时程信息</h2><p>值得注意的是，<code>ElCentro.txt</code>文件中，加速度单位为g，也就是$9.8m/s^2$，注意转化。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=textread(<span class="string">&#x27;ElCentro.txt&#x27;</span>);  <span class="comment">% 先将地震动加速度记录存放在a中，用于下面的处理</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">size</span>(a);                   <span class="comment">% 地震数组维数</span></span><br><span class="line">RecordLength=<span class="built_in">i</span>*<span class="built_in">j</span>;               <span class="comment">% 记录步数</span></span><br><span class="line">A=<span class="built_in">zeros</span>(RecordLength,<span class="number">2</span>);        <span class="comment">% 定义处理后的地震动加速度时程数组，有两列，第一列存放时间，第二列存放对应地震动加速度值</span></span><br><span class="line">A(<span class="number">1</span>:RecordLength,<span class="number">1</span>)= <span class="number">0</span>:<span class="number">0.01</span>:(RecordLength<span class="number">-1</span>)*<span class="number">0.01</span>;  <span class="comment">% 在A中输出时间变量,式中的0.01为记录间隔</span></span><br><span class="line"><span class="keyword">for</span> n1 = <span class="number">1</span>:<span class="number">1</span>:<span class="built_in">i</span>                                           <span class="comment">% 用双重for循环将a中的记录按顺序放入A中</span></span><br><span class="line">    <span class="keyword">for</span> n2=<span class="number">1</span>:<span class="number">1</span>:<span class="built_in">j</span></span><br><span class="line">        A((n1<span class="number">-1</span>)*<span class="built_in">j</span>+n2,<span class="number">2</span>)=a(n1,n2)*<span class="number">9.8</span>*<span class="number">1000</span>;     <span class="comment">% g(9.8 m/s2) 转化为 mm/s2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="定义地震动等效动荷载矩阵"><a href="#定义地震动等效动荷载矩阵" class="headerlink" title="定义地震动等效动荷载矩阵"></a>定义地震动等效动荷载矩阵</h2><p>即：$P=-M\left\{1\right\}{\ddot x}_g$.<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onevector = <span class="built_in">ones</span>(<span class="built_in">size</span>(M,<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line">P = <span class="built_in">zeros</span>(<span class="built_in">size</span>(M,<span class="number">1</span>),RecordLength);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:RecordLength</span><br><span class="line">    P(:,<span class="built_in">i</span>) = -(M*onevector).*A(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="调用中心差分法函数进行求解"><a href="#调用中心差分法函数进行求解" class="headerlink" title="调用中心差分法函数进行求解"></a>调用中心差分法函数进行求解</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x0=<span class="built_in">zeros</span>(<span class="number">8</span>,<span class="number">1</span>);    <span class="comment">% 相对运动的初位移(数值积分用)</span></span><br><span class="line">v0=<span class="built_in">zeros</span>(<span class="number">8</span>,<span class="number">1</span>);    <span class="comment">% 相对运动的初速度(数值积分用)</span></span><br><span class="line">dt = <span class="number">0.01</span>;  <span class="comment">%数值步长(=地震动记录间隔)</span></span><br><span class="line">[x,v,a] = MDOF_CentralDifference(M,K,C,P,x0,v0,dt,RecordLength);</span><br></pre></td></tr></table></figure><h2 id="绘制第1层的位移时程曲线"><a href="#绘制第1层的位移时程曲线" class="headerlink" title="绘制第1层的位移时程曲线"></a>绘制第1层的位移时程曲线</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span></span><br><span class="line">layer_num = <span class="number">1</span>;  </span><br><span class="line"><span class="built_in">plot</span>(A(:,<span class="number">1</span>),x(layer_num,:).&#x27;)       <span class="comment">%绘制第 layer_num 层的相对位移时程曲线</span></span><br><span class="line">title([<span class="string">&#x27;Time-history curve of relative displacement for Layer &#x27;</span>, num2str(layer_num)])   <span class="comment">% 图形标题</span></span><br><span class="line">xlabel(<span class="string">&#x27;time (s)&#x27;</span>)                     <span class="comment">% 图形x坐标</span></span><br><span class="line">ylabel(<span class="string">&#x27;relative displacement (mm)&#x27;</span>)  <span class="comment">% 图形y坐标</span></span><br></pre></td></tr></table></figure><p>上方<code>layer_num</code>是层号，可随意调整，输出该层位移的时程曲线。</p><hr><h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><p>点击下载：<a href="http://s6bqz76rx.hd-bkt.clouddn.com/ElCentro.txt?e=1703764852&amp;token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:Fsfd6Er7C-UVZTt6bQ9MgJU0gvs=">ElCentro.txt</a>、<a href="http://s6bqz76rx.hd-bkt.clouddn.com/MDOF_CentralDifference.m?e=1704474652&amp;token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:7DM9XGzVOvQVMasCCIGKCdl7LEg=">MDOF_CentralDifference.m</a>、<a href="http://s6bqz76rx.hd-bkt.clouddn.com/MDOF_RelativeDisp.m?e=1704474665&amp;token=-d3Y-J__RCFSW2YaqSPXK61uRBa879w5CmloWu6G:Si_TAOiYku8ftBbvydokUpYIqbY=">MDOF_RelativeDisp.m</a>.<br>将上述三个文件放在同一个文件夹下即可在<code>MATLAB</code>上运行，没安装<code>MATLAB</code>的同学可以试试<a href="https://www.mathworks.com/products/matlab-online.html">MATLAB online</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中心差分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2023/Useful%20tools/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/Useful%20tools/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建"><a href="#个人博客搭建" class="headerlink" title="个人博客搭建"></a>个人博客搭建</h1><ol><li>安装<a href="https://nodejs.org/en">Nodejs</a>,这里选择<code>LTS</code>版本，安装好后，运行如下命令(建议使用以管理员方式运行,例如将git bash设置为以管理员方式打开，我是选择始终以管理方式运行git bash)，检查nodejs安装是否成功。<a href="https://git-scm.com/"><strong>Git下载</strong></a>,建议装在系统盘(例如C盘)。<span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查nodejs是否安装成功</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看npm下载的全局保存目录(prefix)和缓存位置(cache)</span></span><br><span class="line"><span class="comment"># 如果在C盘，可以换到D盘某个位置，例如就在Nodejs安装路径下新建`node_global`和`node_cache`两个文件夹。</span></span><br><span class="line"><span class="comment"># 然后更改`Nodejs安装路径\node_modules\npm`下的npmrc和.npmrc文件，加上上述两个文件夹的路径。</span></span><br><span class="line">npm config <span class="built_in">ls</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将Nodejs中的全局保存目录（保存下载的库）和<code>Nodejs安装路径\node_modules\npm</code>放到系统变量中的Path下，如下图所示。</p><div align="center"><img src="/2023/Useful%20tools/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/nodejs添加环境变量.jpg" width="70%"></div><blockquote><p>其中全局保存目录是为了后面<code>hexo</code>命令能顺利运行，而<code>...\npm</code>文件夹则是为了npm能顺利运行。</p></blockquote></li><li><p>然后在博客文件夹（必须是新文件夹）(这里以<code>D:\Blog</code>举例),git bash,运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli <span class="comment">#(下载到全局保存目录)</span></span><br><span class="line"></span><br><span class="line">hexo init <span class="comment"># 博客初始化</span></span><br><span class="line"></span><br><span class="line">npm install hexo-cli  <span class="comment">#下载hexo到`D:\Blog\node_modules`</span></span><br><span class="line"></span><br><span class="line">hexo -v <span class="comment"># 若成功显示版本，则表示hexo安装成功了。</span></span><br><span class="line"></span><br><span class="line">hexo g  </span><br><span class="line"></span><br><span class="line">hexo s  <span class="comment"># 然后再本地打开即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样博客就初步搭建完成了。</span></span><br></pre></td></tr></table></figure></li><li>可以运行<code>hexo new  xxx.md</code>来生成文章，然后运行<code>hexo g</code>，等待部署到github上。</li><li>参考：<a href="https://blog.csdn.net/m0_48121128/article/details/132380427"><strong>完成hexo到GitHub的部署</strong></a>，这里要注意，在博客目录下config.yaml修改时（如下）：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repo:</span> <span class="string">git@github.com:Yourname/Yourname.github.io.git</span>   <span class="comment"># 这里不要用https: 链接，否则后面部署时傻里傻气的。</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">main</span>  <span class="comment">#这里分支要选择好，main是默认的，可以新建分支(比如source)，但要对应github-pages那里生成的分支，如下图所示。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div align="center"><img src="/2023/Useful%20tools/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github%20pages生成选择分支.jpg" width="70%"></div></li><li>再运行<code>npm install hexo-deployer-git --save</code>（否则<code>hexo d</code>无效，无法完成部署）。</li></ol><p><strong>参考资料</strong></p><ol><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029"><strong>搭建个人博客</strong></a></li></ol><h1 id="博客优化"><a href="#博客优化" class="headerlink" title="博客优化"></a>博客优化</h1><h2 id="hexo-d-显示无法连接到-github"><a href="#hexo-d-显示无法连接到-github" class="headerlink" title="hexo d 显示无法连接到 github."></a>hexo d 显示无法连接到 <code>github</code>.</h2><p>运行的<code>hexo d</code>后会报错：</p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/Hushuangjun/Hushuangjun.github.io.git">https://github.com/Hushuangjun/Hushuangjun.github.io.git</a></p></blockquote><p>解决方法：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_46087812/article/details/124575202</span><br></pre></td></tr></table></figure></p><p>如果在搭建过程中，在 <code>_config.yml</code>中设置如下则不会报这个错：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:Hushuangjun/Hushuangjun.github.io.git</span>      <span class="comment">#使用git进行下载，而不是https!</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">theme_anzhiyu</span>    <span class="comment">#对应GitHub上要同步的分支</span></span><br></pre></td></tr></table></figure></p><h2 id="markdown如何插入本地图片"><a href="#markdown如何插入本地图片" class="headerlink" title="markdown如何插入本地图片"></a>markdown如何插入本地图片</h2><p>实际上这个属于markdown的基本语法，使用相对路径即可。<br>GitHub上有作者开发了插件<a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-iamge</a>,更加方便了！<br>参考：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/koo070/p/16548228.html</span><br></pre></td></tr></table></figure></p><h2 id="博客中如何插入自定义大小图片？"><a href="#博客中如何插入自定义大小图片？" class="headerlink" title="博客中如何插入自定义大小图片？"></a>博客中如何插入自定义大小图片？</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/139007418</span><br></pre></td></tr></table></figure><h2 id="博客内嵌pdf直接下载而不显示"><a href="#博客内嵌pdf直接下载而不显示" class="headerlink" title="博客内嵌pdf直接下载而不显示"></a>博客内嵌pdf直接下载而不显示</h2><p>因为我们idm插件接管了那个命令，只要把浏览器的idm插件关闭或者设置在该网站不再自动下载。</p><h2 id="hexo-d每次都需要绑定域名"><a href="#hexo-d每次都需要绑定域名" class="headerlink" title="hexo d每次都需要绑定域名"></a>hexo d每次都需要绑定域名</h2><p>为啥每次<code>hexo d</code>后，在<code>settings-pages</code>那里都要重新配置<code>custom domain</code>?<br>为避免这个麻烦，可以在博客目录下<code>source</code>文件夹下新建<code>CNAME</code>,内容为需要绑定的域名(我的为<code>husj0711.top</code>)。<br>参考<a href="https://blog.csdn.net/weixin_49175501/article/details/128705141">解决方案</a>。</p><h2 id="博客在本地-localhost-4000-查看可以，网络打开排版很乱。"><a href="#博客在本地-localhost-4000-查看可以，网络打开排版很乱。" class="headerlink" title="博客在本地(localhost:4000)查看可以，网络打开排版很乱。"></a>博客在本地(localhost:4000)查看可以，网络打开排版很乱。</h2><p><code>Shift + F5</code>强制刷新页面即可。</p><h2 id="博客文章如何显示数学公式？"><a href="#博客文章如何显示数学公式？" class="headerlink" title="博客文章如何显示数学公式？"></a>博客文章如何显示数学公式？</h2><p>博客采用Mathjax语法显示数学公式。<br>hexo-renderer-marked是hexo默认的渲染器，不支持复杂的数学公式，正是我需要换掉的，安装<strong>hexo-renderer-kramed</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><br>然后修改主题配置文件为：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>博客配置文件中添加：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kramed:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pedantic:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sanitize:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartLists:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>目前的工作流：<br>首先，mathtype敲公式，然后复制，复制配置如下：<br><img src="/2023/Useful%20tools/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/mathtype剪切复制.jpg" alt="mathtype"></p><p>复制得到的公式为：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\frac&#123;&#123; - b \pm \sqrt &#123;&#123;b^2&#125; - 4ac&#125; &#125;&#125;&#123;&#123;2a&#125;&#125;\]</span><br></pre></td></tr></table></figure><br>由于hexo-renderer-kramed不支持<code>\]</code>，故要换成<code>$$</code>(行间)或者<code>$</code>(行内).也即：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;&#123; - b \pm \sqrt &#123;&#123;b^2&#125; - 4ac&#125; &#125;&#125;&#123;&#123;2a&#125;&#125;$$</span><br></pre></td></tr></table></figure></p><p>但是上述还会出现一个问题，多个<code>&#123;</code>之间没有空格，也是渲染报错，需要在它们中间加上空格，或者在公式前后加上<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125; </span><br><span class="line">...</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><br>故有：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123; &#123; - b \pm \sqrt &#123; &#123;b^2&#125; - 4ac&#125; &#125; &#125;&#123; &#123;2a&#125; &#125;$$</span><br></pre></td></tr></table></figure><br>或者<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">$$\frac&#123;&#123; - b \pm \sqrt &#123;&#123;b^2&#125; - 4ac&#125; &#125;&#125;&#123;&#123;2a&#125;&#125;$$</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></p><p>最终显示效果：</p><script type="math/tex; mode=display">\frac{ { - b \pm \sqrt { {b^2} - 4ac} } }{ {2a} }</script><p>至此，绝大数公式就能显示啦！</p><h2 id="如何实现博客utterances评论系统？"><a href="#如何实现博客utterances评论系统？" class="headerlink" title="如何实现博客utterances评论系统？"></a>如何实现博客utterances评论系统？</h2><p>这个是针对<code>NexT</code>主题的！！！<br>参考：</p><ol><li><a href="https://bambrow.com/20230625-hexo-comment-utterances/#more">Hexo NexT 使用 utterances 评论区</a></li><li><a href="https://utteranc.es/?installation_id=45240142&amp;setup_action=install">utterances</a></li></ol><p>上述文献[2]中，需要将下列代码添加到博客模板文件(<code>D:\Blog\themes\next\layout\_layout.njk</code>)中.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span><br><span class="line">        repo=<span class="string">&quot;[ENTER REPO HERE]&quot;</span></span><br><span class="line">        issue-term=<span class="string">&quot;[ENTER TERM HERE]&quot;</span></span><br><span class="line">        theme=<span class="string">&quot;github-light&quot;</span></span><br><span class="line">        crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zotero 插件推荐</title>
      <link href="/2023/Useful%20tools/Zotero%20%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/Useful%20tools/Zotero%20%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Zotero-better-notes"><a href="#Zotero-better-notes" class="headerlink" title="Zotero better notes"></a>Zotero better notes</h1><p>Zotero借助插件<a href="https://github.com/windingwind/zotero-better-notes">zotero better notes</a>可以很好地实现markdown写作。<br><img src="/2023/Useful%20tools/Zotero%20%E6%8F%92%E4%BB%B6/zotero-better-notes实现markdown写作.jpg" alt="Zotero better notes"></p><h1 id="Zotfile"><a href="#Zotfile" class="headerlink" title="Zotfile"></a>Zotfile</h1><p>借助<a href="https://github.com/jlegewie/zotfile">zotfile</a>插件可以实现pdf附件以资源管理器那样文件夹式分类存储，条理清晰！如下图所示：<br><img src="/2023/Useful%20tools/Zotero%20%E6%8F%92%E4%BB%B6/zotfile实现文件夹式分类.jpg" alt="Zotfile"></p><p>具体可以看我下面这个视频。</p><div style="display: flex; justify-content: center;">    <iframe src="//player.bilibili.com/player.html?aid=351016062&bvid=BV1sR4y1b7rB&cid=987099716&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="800" height="450"></iframe></div><h1 id="Zotero-PDF-translate"><a href="#Zotero-PDF-translate" class="headerlink" title="Zotero PDF translate"></a>Zotero PDF translate</h1><p><a href="https://github.com/windingwind/zotero-pdf-translate">Zotero PDF translate</a>可以实现选词翻译，在阅读英文文章过程中很好用！<br>缺点就是不用科学上网的话体验比较糟糕！<br><img src="/2023/Useful%20tools/Zotero%20%E6%8F%92%E4%BB%B6/zotero翻译插件.jpg" alt="zotero pdf transalte"></p>]]></content>
      
      
      <categories>
          
          <category> 科研工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 系列教程</title>
      <link href="/2023/Useful%20tools/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
      <url>/2023/Useful%20tools/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode配置C"><a href="#VScode配置C" class="headerlink" title="VScode配置C"></a>VScode配置C</h1><ol><li>由于C语言是编译型语言，而vscode仅仅是一个代码编辑器，故需要先配置编译器，这里我选择mingw-w64的<a href="https://sourceforge.net/projects/mingw-w64/files/"><strong>gcc编译器</strong></a>。注意下载后需要将”….\mingw64\bin”放到环境变量（系统和用户环境变量都可，选一种即可）。</li><li>然后在vscode上下载扩展插件(C/C++),这里要注意，尽量安装版本较老的，否则不会自动生成launch.json文件。如果实在没法自动生成，可自己配置，参考<a href="https://blog.csdn.net/m0_63702526/article/details/130136859">VSCode配置C/C++</a>等多篇文章.</li><li>配置好之后，可以运行C/C++源文件了，但发现：<strong>终端窗口在程序一运行完就立即消失了</strong>，于是上网查阅了各种办法，选择了两种运行方式：（具体见配置文件 <code>launch.json</code> 和<code>tasks.json</code>。当然，两者都是gcc编译的。）<ol><li>在外终端（C:\WINDOWS\system32\cmd.exe）运行可执行文件(.exe)。</li><li>在内终端(D:\Computer Softwares\Visual studio code\Codes..)(即项目所在地址，相当于直接git bash here) 运行可执行文件(.exe)。</li></ol></li><li>但是很快就发现一个问题，外终端运行时打印汉字会乱码，于是在<code>tasks.json</code>文件中增加<code>&quot;-fexec-charset=GBK&quot;</code>，但很快就发现，内终端运行时就乱码了。于是查阅<a href="https://blog.csdn.net/weixin_43439450/article/details/118331694"><strong>网上一些资料</strong></a>，进行如下操作即可实现内外终端均不会乱码。<ol><li>将cmd的编码（解码）方式由默认的<code>gbk</code>换成<code>utf-8</code>,具体参考<a href="https://blog.csdn.net/qq_43768851/article/details/123501124"><strong>如何更改cmd的编/解码格式</strong></a>.</li><li>将gcc的编/解码方式也换成<code>utf-8</code>,(这也是gcc默认的)，在<code>tasks.json</code>文件中增加<code>&quot;-finput-charset=UTF-8&quot;</code>,删掉原来的<code>&quot;-fexec-charset=GBK&quot;</code>.</li></ol></li><li>至此，就完成了VScode对C/C++的配置！<br>注意：<ol><li><strong>项目所在地址应为英文路径</strong>，否则编译器会报错。</li><li>配置好的<code>c_cpp_properties.json</code>、<code>lanuch.json</code>和<code>task.json</code>见<a href="https://pan.baidu.com/s/1PKbGVBoxTYaMnY56qU3W2w?pwd=8jda">链接</a>,提取码:8jda.将这三个文件放入<code>.vscode</code>文件夹下，即可完美运行<strong>C源文件</strong>，对于<strong>C++源文件</strong>目前还未测试。</li><li>对于多个C文件同时运行是不支持的，可能因为<strong>编译生成的程序名称还是以c源文件名称来命名的原因吧</strong>，可能要在task.json和launch.json文件下改。<ol><li>对的，task.json中args参数改动：：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">改为<span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;workspaceFolder&#125;\\*.c&quot;</span><span class="punctuation">,</span><span class="comment">//c++代码就改这里后缀为.cpp</span></span><br><span class="line"><span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;$&#123;workspaceFolder&#125;\\$&#123;workspaceRootFolderName&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>launch.json文件改动如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;\\$&#123;workspaceRootFolderName&#125;.exe&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li>这样就变成VS了，会编译项目文件下所有C文件，集成到以项目名称命名的程序下。</li></ol></li></ol></li></ol><h1 id="VSCode配置python虚拟环境"><a href="#VSCode配置python虚拟环境" class="headerlink" title="VSCode配置python虚拟环境"></a>VSCode配置python虚拟环境</h1><ol><li><strong>安装 Python 插件：</strong><ul><li>打开 VSCode。</li><li>在扩展视图中搜索并安装 Python 插件（一般是由 Microsoft 提供的 Python 插件）。</li></ul></li><li><p><strong>创建虚拟环境：</strong></p><ul><li>打开 VSCode 中的终端（可以使用 <code>Ctrl +</code> <code> </code> 或者点击顶部菜单的“视图”-&gt;“终端”）。</li><li><p>在终端中使用以下命令创建虚拟环境（假设你的项目在当前目录下，你可以替换 <code>venv</code> 为你喜欢的虚拟环境名称）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><p>如果你使用的是 Python 3.3 或更早版本，可以使用 <code>virtualenv</code> 替代 <code>venv</code>。</p></li></ul></li><li><p><strong>激活虚拟环境：</strong></p><ul><li><p>在终端中使用以下命令激活虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\venv\Scripts\activate</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>安装所需的包：</strong><ul><li>在虚拟环境中，使用 <code>pip</code> 安装你项目所需的依赖包，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>在 VSCode 中选择虚拟环境：</strong><ul><li>打开你的项目文件夹。</li><li>在左下角的状态栏中，你应该能够看到当前使用的 Python 解释器。如果没有显示，点击并选择虚拟环境的 Python 解释器。</li></ul></li></ol><blockquote><p><a href="https://baijiahao.baidu.com/s?id=1767913548598914679&amp;wfr=spider&amp;for=pc">参考资料</a></p></blockquote><p><strong>Python-Pyinstaller 实现程序打包</strong><br>示例：<code>pyinstaller -F -c -i icon.ico myscript.py</code>.</p><p><strong>具体参数见下表</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">参数作用</th></tr></thead><tbody><tr><td style="text-align:center">-F, —onefile</td><td style="text-align:center">打包一个单个文件，如果你的代码都写在一个 py 文件的话，可以用这个。如果是多个 py 文件就别用</td></tr><tr><td style="text-align:center">-D, —onedir</td><td style="text-align:center">打包多个文件，在 dist 中生成很多依赖文件，适合以框架形式编写工具代码，我个人比较推荐这样，代码易于维护</td></tr><tr><td style="text-align:center">-K, –tk</td><td style="text-align:center">在部署时包含 TCLTK</td></tr><tr><td style="text-align:center">-a, —ascii</td><td style="text-align:center">不包含编码。在支持 Unicode 的 Python 版本上默认包含所有的编码</td></tr><tr><td style="text-align:center">-d, —debug</td><td style="text-align:center">产生 debug 版本的可执行文件</td></tr><tr><td style="text-align:center">-w, —windowed, —noconsole</td><td style="text-align:center">使用 Windows 子系统执行。当程序启动的时候不会打开命令行（只对 Windows 有效）</td></tr><tr><td style="text-align:center">-c, —nowindowed, —console</td><td style="text-align:center">使用控制台子系统执行（默认）（只对 Windows 有效）。pyinstaller-c xxxx.py</td></tr><tr><td style="text-align:center">-s, —strip</td><td style="text-align:center">可执行文件和共享库将 run through strip。注意 Cygwin 的 strip 往往使普通的 win32 Dll 无法使用</td></tr><tr><td style="text-align:center">-X, —upx</td><td style="text-align:center">如果有 UPX 安装（执行 Configure.py 时检测），会压缩执行文件（Windows 系统中的 DLL 也会）（参见 note）</td></tr><tr><td style="text-align:center">-o DIR, —out=DIR</td><td style="text-align:center">指定 spec 文件的生成目录，如果没有指定，而且当前目录是 PyInstaller 的根目录，会自动创建一个用于输出（spec 和生成的可执行文件）的目录。如果没有指定，而当前目录不是 PyInstaller 的根目录，则会输出到当前的目录下</td></tr><tr><td style="text-align:center">-p DIR, —path=DIR</td><td style="text-align:center">设置导入路径（和使用 PYTHONPATH 效果相似）。可以用路径分割符（Windows 使用分号，Linux 使用冒号）分割，指定多个目录。也可以使用多个 -p 参数来设置多个导入路径，让 PyInstaller 自己去找程序需要的资源</td></tr><tr><td style="text-align:center">-icon=<FILE.ICO></FILE.ICO></td><td style="text-align:center">将 file.ico 添加为可执行文件的资源（只对 Windows 系统有效），改变程序的图标。pyinstaller -i ico 路径 xxxxx.py</td></tr><tr><td style="text-align:center">-icon=<FILE.EXE,N></FILE.EXE,N></td><td style="text-align:center">将 file.exe 的第 n 个图标添加为可执行文件的资源（只对 Windows 系统有效）</td></tr><tr><td style="text-align:center">-V FILE, —version=FILE</td><td style="text-align:center">将 verfile 作为可执行文件的版本资源（只对 Windows 系统有效）</td></tr><tr><td style="text-align:center">-n NAME, —name=NAME</td><td style="text-align:center">可选的项目（产生的 spec 的）名字。如果省略，第一个脚本的主文件名将作为 spec 的名字</td></tr></tbody></table></div><p>参考文献</p><blockquote><p><a href="https://blog.csdn.net/BearStarX/article/details/81054134">pyinstaller参数介绍以及总结</a></p></blockquote><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h2><p>参考<a href="https://blog.csdn.net/thesat/article/details/122657537">hexo搭建博客</a>，这里详细讲了如何配置GitHub的shh密钥。<br>最后可运行<code>ssh -T git@github.com</code>,看是否出现<code>Hi Hushuangjun! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>,出现的话就说明配置成功了。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol><li>基本版本控制<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init  //初始化文件夹</span><br><span class="line"></span><br><span class="line">git add . //添加目前文件路径下所有文件到暂存区</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;版本号(根据修改内容填写)&quot;</span>  //提交</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>GitHub仓库(假设有一个test.git仓库)同步<ol><li>先在GitHub上创建仓库(test.git).</li><li>复制仓库地址.<code>https://github.com/Hushuangjun/test.git</code><br>然后在本地版本控制的文件夹下运行如下代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Hushuangjun/test.git  //将本地文件夹与远程服务器中仓库关联</span><br><span class="line"></span><br><span class="line">git push -u origin main //推送到远程仓库，其中main是要推送的分支。</span><br></pre></td></tr></table></figure>如果你这个仓库是<code>fork</code>别人的，那么最好还需跟上游仓库(也就是原有仓库)建立连接，以便后续方便从上游仓库获取更新和为上游仓库的变更创建本地分支(做一个贡献者).<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https:<span class="regexp">//gi</span>thub.com<span class="regexp">/真正作者的名字/</span>test.git</span><br></pre></td></tr></table></figure><h2 id="Git配置代理"><a href="#Git配置代理" class="headerlink" title="Git配置代理"></a>Git配置代理</h2>参考：<a href="https://ericclose.github.io/git-proxy-config.html#%E5%AE%9E%E4%BE%8B-1">一文让你了解如何为 Git 设置代理</a></li></ol></li></ol><h2 id="Git命令集合"><a href="#Git命令集合" class="headerlink" title="Git命令集合"></a>Git命令集合</h2><p><img src="/2023/Useful%20tools/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/Git命令集合.png" alt="Git常用命令"></p><h1 id="VSCcode-断点调试"><a href="#VSCcode-断点调试" class="headerlink" title="VSCcode-断点调试"></a>VSCcode-断点调试</h1><p>当在 Visual Studio Code (VSCode) 中进行断点调试时，通常会使用一系列调试控制命令来控制代码的执行。以下是一些常见的断点调试控制命令以及它们之间的区别：</p><ol><li><strong>继续：</strong><ul><li>从当前断点继续执行代码直到下一个断点或程序结束。如果没有设置断点，将一直执行到程序结束。</li></ul></li><li><strong>逐过程：</strong><ul><li>点一下运行当前行代码，并把高亮标志移动到下一行。如果当前行是一个函数，运行整个函数，而不会进入函数内部。</li></ul></li><li><strong>单步调试：</strong><ul><li>逐行执行代码，如果当前行包含函数调用，则进入该函数内部。</li></ul></li><li><strong>单步跳出：</strong><ul><li>执行完当前函数的剩余部分，并停在调用该函数的地方。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电子书籍查找教程</title>
      <link href="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/"/>
      <url>/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="电子书查找教程"><a href="#电子书查找教程" class="headerlink" title="电子书查找教程"></a>电子书查找教程</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用<strong>科学上网</strong>，在google上搜索相关书籍，可能会找到相关电子版。如下图所示。<br><span id="more"></span></p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/google搜索电子书.jpg" width="90%"></div><h3 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h3><ol><li><p>先在浏览器上安装<a href="https://greasyfork.org/zh-CN"><strong>油猴插件</strong></a>，</p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/浏览器安装油猴插件.jpg" width="90%"></div><p>然后在<a href="https://greasyfork.org/zh-CN/">https://greasyfork.org/zh-CN/</a> 上安装网页脚本，这里推荐一个如下：<br><a href="https://greasyfork.org/zh-CN/scripts/457620-%E5%9B%BE%E4%B9%A6%E4%BA%92%E5%8A%A9-%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%8F%82%E8%80%83%E5%92%A8%E8%AF%A2%E8%81%94%E7%9B%9F-%E8%AF%BB%E7%A7%80">图书互助-图书馆参考咨询联盟-读秀</a></p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/油猴插件.jpg" width="90%"></div></li><li><p>然后打开<a href="http://www.ucdrs.superlib.net/"><strong>全国图书馆参考咨询联盟</strong></a>,(注册、登录过程省略)，输入自己一本想要的书，这时你会发现每本书下面都有一个<strong>图书互助</strong>，如下图所示。</p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/全国图书馆参考联盟查书.jpg" width="90%"></div></li><li><p>点击<strong>图书互助</strong>，会跳转到另一个网站：<a href="http://tushu.163pdf.xyz/">互助助手</a>,如果这本书有电子资源，则会提示如下：</p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（能查到书）.jpg" width="70%"></div>如果显示如下画面，则这个网站（或者脚本）不能找到该资源。<div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（未查到书）.jpg" width="70%"></div></li><li><p>如果能找到，则点击<strong>发起互助</strong>，可能会提示你登录（如果你没登录<strong>互助助手</strong>这个网站的话）。</p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（登录）.jpg" alt="互助助手" width="70%"></div><p>然后你可以在这个网站上购买积分，步骤如下：</p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-1.jpg" width="70%"></div><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-2.jpg" width="70%"></div><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-34.jpg" width="70%"></div><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-5.jpg" width="70%"></div><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-6.jpg" width="70%"></div></li><li><p>登录之后，再次进入搜书界面，刷新一下，再点击<strong>图书互助</strong>，如下图所示：</p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/刷新卡密.jpg" width="70%"></div></li><li><p>然后再次跳转到<strong>互助助手</strong>，再次<strong>发起互助</strong>，过半分钟左右，就有百度网盘链接了。</p><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/发起互助.jpg" width="70%"></div><div align="center"><img src="/2023/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/百度网盘链接.jpg" width="70%"></div></li></ol><p><strong>至此，你就能一元下载一本书的电子版啦！，比TB、PDD上商家实惠多了</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大端与小端</title>
      <link href="/2023/Specific%20subject/01%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/"/>
      <url>/2023/Specific%20subject/01%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>最近做了小甲鱼<a href="https://fishc.com.cn/thread-74266-1-1.html"><strong>练习题</strong></a>，学习了什么是<a href="https://fishc.com.cn/thread-75394-1-1.html"><strong>大端和小端</strong></a>，后面有空来填坑。</p><p>(2023-12-11)回来补坑啦!</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>大端：<strong>高位字节</strong>排放在内存的低地址端，而低位字节排放在内存的高地址端。</p><div align="center"><img src="/2023/Specific%20subject/01%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/大端.jpg" width="90%"></div><p>小端：<strong>低位字节</strong>排放在内存的低地址端，高位字节排放在内存的高地址端。</p><div align="center"><img src="/2023/Specific%20subject/01%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/小端.jpg" width="90%"></div><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p>现在请编写一个程序，测试一下你当前的计算机是大端还是小端？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span> * p = (<span class="type">char</span> *)&amp;num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p &gt; *(p+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的电脑采用小端字节序。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的电脑采用大端字节序。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x 在内存中依次存放为: &quot;</span>,num);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%x &quot;</span>,*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果输出：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你的电脑采用小端字节序。</span><br><span class="line"><span class="number">0x12345678</span> 在内存中依次存放为: <span class="number">0x78</span> <span class="number">0x56</span> <span class="number">0x34</span> <span class="number">0x12</span> </span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-迷路的指针</title>
      <link href="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/"/>
      <url>/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol><li>getchar()函数<ol><li><strong>只能从键盘缓冲区接收字符，一次只能接收一个字符</strong>。如果之前有<code>scanf(&quot;%c&quot;,&amp;str);</code>类似语句，回车键<code>\n</code>也被会当作一个字符留在键盘缓冲区。如果不是char类型倒不要紧。</li><li>如果之前没有用scanf()接收过字符,那么使用getchar()函数时，需要先键入字符，<strong>按enter键后</strong>，键入的字符(串)进入缓冲区，然后getchar会从中取一个字符(按输入的顺序)，以后每次调用getchar()都会从缓冲区接收一个字符，直至缓冲区字符用完，再重复以上步骤。</li><li>getchar()函数的返回值也不是字符而是一个整型.(读取成功时就返回该字符的ASCⅡ值，失败时就返回一个-1。)</li><li>典型例题：加密电文，所有大小写英文字母＋4(ASCII码) 循环，其余字符不变。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; (str=getchar()) != <span class="string">&#x27;\n&#x27;</span> ; )&#123;</span><br><span class="line">        <span class="keyword">if</span> (str&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str &gt;= <span class="string">&#x27;A&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;A&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>scanf()函数</p><ol><li><p>scanf()函数返回值是是成功读取并赋值的参数的数量。<br>scanf()函数返回值分为3种：<br>(1). 返回正整数。表示正确输入参数的个数。<br>(2). 返回整数0。表示用户的输入不匹配，无法正确输入任何值。<br>(3). 返回-1。表示输入流已经结束。在Windows下，用户按下CTRL+Z（会看到一个^Z字符）再按下回车（可能需要重复多次），就表示输入结束；Linux/Unix下使用CTRL+D表示输入结束。</p><p>参考如下例题：<a href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>.<br>上述例题的两种解法：(链接中已给出一种，下给出另一种)    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j,d[<span class="number">3</span>];</span><br><span class="line">   <span class="type">int</span> judge = <span class="number">1</span>,count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; judge;)&#123; <span class="comment">//判断条件是judge不为0.</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[j]);</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">               judge = <span class="number">0</span>; <span class="comment">//遇到换行符即表示输入结束。</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (j == <span class="number">3</span> &amp;&amp; (d[<span class="number">0</span>] + d[<span class="number">1</span>] == d[<span class="number">2</span>]))&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>scanf()也是从键盘缓冲区得到输入，一般来说，遇到换行符<code>\n</code>就表示输入项结束了，但在上述例子<a href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>中，scanf由于一次性需要接收三个参数，此时换行符<code>\n</code>就不起作用了，需要手动敲<code>ctrl + z</code>再按回车。<strong>windows上，<code>ctrl + z</code>就表示输入项的结束</strong>。具体可参考<a href="https://blog.csdn.net/i6223671/article/details/89041492">详解输入输出流结束标志ctrl+z和EOF</a>.</li></ol></li><li>逗号表达式<br>逗号表达式一般形式为: <code>expr1, expr2, expr3,...,exprn</code>.<br>逗号表达式从左到右依次求值，每个表达式的值被忽略，除了最后一个表达式。逗号表达式的值就是最后一个表达式的值。   </li><li><p>运算符优先级及结合性<br>结论：<strong>先计算优先级大的，相同优先级再根据结合性计算</strong>。<br><div align="center"><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/运算符优先级及结合性.jpg" width="90%"></div><br>观察如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">5</span>, y;</span><br><span class="line"></span><br><span class="line">   y = <span class="number">2</span> * x++;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;x = %d&quot;</span>,x);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;y = %d&quot;</span>,y);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是:</p><blockquote><p>x = 6; y = 10;</p></blockquote><p>于是疑问出现了，自增运算符<code>++</code>优先级不是大于乘<code>*</code>吗？不是先自增再乘嘛，这样<code>y = 2*6 = 12</code>.<br>其实：程序确实先进行自增运算符，但<code>++x和x++</code>返回的结果是不同的，然后再赋值给y。<strong>特别是x++，它的返回值就是x，而++x的返回值是x + 1</strong>, 所以造成一种假象，以为先进行了乘法运算。<br>小试牛刀：  </p><blockquote><p>关于<code>str = &#39;!&#39;; 48 &lt;= str &lt;= 57</code>为啥总是得到1？</p></blockquote><p>因为<code>&lt;=</code>的结合性是自左向右，故先会计算<code>48 &lt;= str</code>,此时str = ‘!’,ASCII值是33，故返回值是0.再计算<code>0 &lt;= 57</code>,返回值是1.由此可以看出学了python之后，再学C感觉步骤很啰嗦。但正是因为步骤啰嗦（分类齐全，条理清晰），故C速度很快。</p></li></ol><h2 id="选择结构程序设计"><a href="#选择结构程序设计" class="headerlink" title="选择结构程序设计"></a>选择结构程序设计</h2><ol><li>注意<code>if - else if - else</code>，按顺序判断，只要其中一个条件为真，剩下的就不会执行！<br>如果<strong>没有大括号就遵循就近原则</strong>，所以写的时候尽量带上大括号。例如:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">      <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>最后结果什么也不会输出！！因为其相当于<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>switch</code>选择语句：注意表达式A的值必须为整型数据（当然包括字符型），而a、b…必须是常量或者常量表达式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式A) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> a:  表达式<span class="number">1</span>  ; <span class="keyword">break</span>;  <span class="comment">// 必须加上break，否则后续case会一直执行，直到break或者全部读完。</span></span><br><span class="line">   <span class="keyword">case</span> b:  表达式<span class="number">2</span>  ; <span class="keyword">break</span>;  <span class="comment">// 表达式A的值为a\b..时，就执行对应语句。</span></span><br><span class="line">   <span class="keyword">case</span> c: &#123; <span class="comment">// 也可以写成这样。</span></span><br><span class="line">     表达式<span class="number">1</span>;</span><br><span class="line">     表达式<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">default</span>:  表达式n ; <span class="keyword">break</span>;  <span class="comment">// 可以不用break,反正都结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>C语言中唯一一个三目运算符：条件运算符(<code>? :</code>)，对应表达式就是条件表达式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b ? a:b</span><br><span class="line"><span class="comment">//条件语句</span></span><br><span class="line">c = a &gt; b ? a:b ;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">   c = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   c = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环结构程序设计"><a href="#循环结构程序设计" class="headerlink" title="循环结构程序设计"></a>循环结构程序设计</h2></li><li><code>while</code>循环：表达式为真，进入循环，直至表达式为假或者<code>break;</code>跳出循环.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>do while</code>循环：特别注意while后面还有个分号<code>;</code>.  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>；</span><br><span class="line">   ...</span><br><span class="line">&#125; <span class="keyword">while</span> (表达式) ;  </span><br></pre></td></tr></table></figure></li><li><code>for</code>循环:其中表达式1和3可以为<strong>逗号表达式</strong>，表达式2是判断条件，为真的话继续。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) </span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line">表达式<span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">   表达式<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组定义及初始化"><a href="#数组定义及初始化" class="headerlink" title="数组定义及初始化"></a>数组定义及初始化</h3><p>一维数组定义：(二维数组同理)</p><blockquote><p>类型符  数组名[常量表达式]</p></blockquote><p>特别注意是<strong>常量表达式</strong>，不能是<strong>变量</strong>。<br>但是！C99推出了<strong>变长数组</strong>(Variable Length Array，VLA),它允许在运行时动态地定义数组的长度，但一旦定义，在其生命周期内大小不可改变。<br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of rows: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;rows);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of columns: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cols);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> matrix[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同时，值得注意的是，<strong>VLA不允许在定义的时候初始化</strong>！<br>例如<code>int matrix[rows][cols] = &#123;0&#125;;</code>，编译器会报错。</p><hr><p>二维数组是一维数组线性拓展得到的，也是以线性的方式存储的。<br>数组名的值数组第一个元素的地址，相当于是一个常量，是不能被赋值的。因此下列数组初始化是错误的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="字符串输入与输出"><a href="#字符串输入与输出" class="headerlink" title="字符串输入与输出"></a>字符串输入与输出</h3><p>   如何直接输出字符串？或者输入字符串?<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出, str是已定义的字符串数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">put(str);  <span class="comment">// 特别注意put不能输出多个字符串,而printf()可以。</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); <span class="comment">//由于str的值就是数组第一个元素的地址，故不需要取值符`&amp;`.同时，输入的字符串大小应不大于定义的字符数组的大小。</span></span><br><span class="line">get(str); <span class="comment">//同理，一次只能接收一个字符串数组。</span></span><br></pre></td></tr></table></figure></p><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">作用</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">puts(str)</td><td style="text-align:center">输出<strong>单个</strong>字符串</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">gets(str)</td><td style="text-align:center">输入<strong>单个</strong>字符串</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">strlen(str)</td><td style="text-align:center">测量字符串的长度</td><td style="text-align:center">返回字符串的长度(不包括<code>\0</code>)</td></tr><tr><td style="text-align:center"><strong>sizeof(str)</strong></td><td style="text-align:center">测量字符串的内存大小</td><td style="text-align:center">返回字符串的内存大小(注意，如果字符串没规定大小，如<code>char str[] = &quot;string&quot;;</code>,则返回值包括<code>\0</code>,如果规定大小了，则返回的值该大小所占字节。)</td></tr><tr><td style="text-align:center">补充：sizeof(array)</td><td style="text-align:center">测量其他类型数组的内存大小</td><td style="text-align:center">返回其他类型数组的内存大小(此时并没有<code>\0</code>的烦恼了)</td></tr><tr><td style="text-align:center">strcat(str1, str2)</td><td style="text-align:center">将<strong>字符串2</strong>接到<strong>字符串1</strong>后面</td><td style="text-align:center">返回的是字符串1的地址</td></tr><tr><td style="text-align:center">strcpy(str1, str2)</td><td style="text-align:center">将字符串2(包括<code>\0</code>)复制到字符串1中</td><td style="text-align:center">返回的是字符串1的地址</td></tr><tr><td style="text-align:center">strncpy(str1, str2, n)</td><td style="text-align:center">将字符串2前n个字符复制到字符串1中</td><td style="text-align:center">返回的是字符串1的地址</td></tr><tr><td style="text-align:center">strlwr(str)</td><td style="text-align:center">将字符串中大小写字母变成<strong>小写字母</strong></td><td style="text-align:center">不返回任何值，对于字符串是原位修改</td></tr><tr><td style="text-align:center">strupr(str)</td><td style="text-align:center">将字符串中大小写字母变成<strong>大写字母</strong></td><td style="text-align:center">不返回任何值，对于字符串是原位修改</td></tr><tr><td style="text-align:center">strcmp(str1, str2)</td><td style="text-align:center">依次比较str1和str2中字符的大小，按照ASCII码比较</td><td style="text-align:center">str1==str2,则返回0；str1 &gt; str2,则返回一个正整数;str1 &lt; str2，则返回一个负整数.</td></tr></tbody></table></div><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针与指针变量"><a href="#指针与指针变量" class="headerlink" title="指针与指针变量"></a>指针与指针变量</h3><p>指针变量也是一个变量，占用的字节大小取决于其<strong>存储的内存地址</strong>的大小，而常说的指针应该是指针变量，其值是“内存地址”（指针）。<br><strong>需要说明的是</strong>：后续所讲<code>指针</code>多指<code>指针变量</code>,例如p指向变量a,完整的说法是：p的值是变量a的地址。</p><p>前提:int x = 10, *y; y = &x;<br><strong>重点：可以认为*y == x。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指针变量，&amp;为取地址运算符</span></span><br><span class="line"><span class="type">char</span> *pa = &amp;a;   <span class="comment">//用char是因为指针变量所储存的内存地址所对应的数据类型是char.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pa); <span class="comment">//打印内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*pa); <span class="comment">//打印变量a的值，这里*是取值运算符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也即：</span></span><br><span class="line">*(&amp;a) = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>下面以小甲鱼的一道课后习题来介绍：<br>Q:请问下边代码执行后，打印机的结果是什么？另外，*b 是左值（l-value）还是右值（r-value）？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">110</span>;</span><br><span class="line">   <span class="type">int</span> *b = &amp;a;</span><br><span class="line">   *b = *b - <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>打印结果是 a = 10.</p></blockquote><p>第一个问题：定义指针变量 b 的时候，存放的是变量 a 的地址。在此之后，*b 即对变量 a 的间接访问（通过地址访问 a 变量）。所以 *b = *b - 10; 相当于 a = a - 10; 也就是说，<strong>通过指针对一个变量间接访问，你可以理解为把它作为那个变量本身使唤</strong>（即 *b == a）.</p><p>第二个问题：<strong>指针变量 b 既是左值，也是右值</strong>。</p><p>此外，关于取址符（&amp;）还有个疑问：一般来说取址符作用对象是左值（lvalue），而数组名不是左值，为啥取址符还可以作用于数组名？<br>A：其实左值下面有个子集——可修改的左值，位于等式左边必须要求可修改的左值！由此可见，之前一直存在认知误区，其实数组名是左值，只是不可修改罢了。于是有以下结论：</p><ul><li>取址符作用于左值，数组名是左值（不可修改的左值），故可将取址符作用于数组名！！！</li></ul><p>参考： <a href="https://blog.csdn.net/imred/article/details/45441457">数组和指针的区别</a></p><h3 id="一维数组与指针的关系"><a href="#一维数组与指针的关系" class="headerlink" title="一维数组与指针的关系"></a>一维数组与指针的关系</h3><p>(不特别说明，数组均指一维数组)<br><strong>数组名==指针变量</strong>，数组名储藏着数组第一个元素的地址，对于<strong>字符数据类型</strong>，可以直接用指针创建数组，下面代码演示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a = <span class="string">&quot;OUC&quot;</span>;  </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]); <span class="comment">//此处相当于是 a[i] = *(a+i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然而对于int等类型，通过指针创建是行不通，究其原因，是因为字符数组就是第一个字符的地址（指针变量），且字符数组名和其他数组名一样，也是指针变量，指向数组第一个元素。</p><blockquote><p>char str[] = “string”;<br>上述str和”string”都可以当作指针变量。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*(<span class="string">&quot;sting&quot;</span>)); <span class="comment">//会输出&#x27;s&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过指针访问数组</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d, *(p+1) = %d.\n&quot;</span>,*p, *(p+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果就是:</p><blockquote><p>*p = 1, *(p+1) = 2.</p></blockquote><p>这就是通过<strong>指针间接访问数组的办法，区别于下标直接访问法</strong>。<br>此处要注意的是，只有当指针指向数组元素时，指针算术运算才有意义，否则就会给未用地址乱赋值，就会报错(Segmetation default)。<br>既然数组名也是一个指针变量，那么同理也用数组名进行访问，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d, *(a+1) = %d.\n&quot;</span>,*a, *(a+<span class="number">1</span>));  <span class="comment">//这个为后续指针数组做下铺垫，例如int (*ptr)[5] = &amp;a;  这里ptr是一个指针变量，存着数组a的地址，*ptr就是数组a，也就代表着数组第一个元素的地址。从而有</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int (*ptr)[5] = &amp;a;</span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    for (i = 0; i&lt;5; i++)&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d&quot;,*(*ptr+i));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>⭐⭐⭐同时又可以发现：<strong>指针所指向的数据类型决定指针的跨度。</strong></p><h3 id="指针与数组的区别"><a href="#指针与数组的区别" class="headerlink" title="指针与数组的区别"></a>指针与数组的区别</h3><p>指针变量是左值(lvalue)，可以修改的；而数组名是地址常量，不可以修改，故不是左值。<br>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> str[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *target = str;  </span><br><span class="line">    <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*target++ != <span class="number">3</span>)  <span class="comment">//此处必须用指针变量，不能用数组名。</span></span><br><span class="line">    <span class="comment">// 这里*target++是啥呢？ 由于增运算符(变量++)的优先级大于取值运算符(*)，故先进行target++,再取值*，相当于*(target++)。</span></span><br><span class="line">    <span class="comment">//同时，还需注意，自增运算符在变量后面，故取值符(*)取用的是未自增前的值。</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总共有%d个数字\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>小甲鱼作业S1E22第2题</strong>：</p><blockquote><p>请问 str[20] 是否可以写成 20[str]？<br>A: C 语言中，<code>a[b]</code> 被解释为 <code>*(a + b)</code>,故两者等价。</p></blockquote><h3 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h3><p>指针数组是指数组元素全为指针的数组；数组指针是一个指针，它指向的是一个数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区分下列哪个是指针数组，哪个是数组指针</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>];  <span class="comment">//int (*p)[5]就相当于int a[5]，a就是数组地址！！！ (区别于数组首地址，后面会讲到)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ ]优先级大于*；虽然[]和()优先级一样，但结合性是从左到右，故第一个是指针数组，第二个是数组指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>指针数组的一个用途：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *p[<span class="number">3</span>] = &#123;   <span class="comment">//由于指针数组存放的都是指针，而数组名就是指针变量。</span></span><br><span class="line">        <span class="string">&quot;让编程改变世界&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Just do it!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;一切皆有可能&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[i]);  <span class="comment">// %s是通过字符串首地址输出字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关于数组指针还有一个坑，数组指针指向的是一个数组，而我们之前常用<code>int *p = temp;</code>(此处temp是一个已定义的整型数组)来将<code>指针指向数组</code>,但实际上，<strong>指针只是指向了数组第一个元素的地址</strong>。现在我们要想数组指针指向整个数组，需使用<code>int (*p)[5] = &amp;temp</code>;这里<code>&amp;temp</code>相当于将整个数组看作一个整体来看待的。(必须清楚的是，数组第一个元素的地址跟整个数组的地址是相同的。)举例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// int (*p)[5] = temp;  //输出也可以，因为把数组当作整体给出地址还是数组首地址，但编译器会提醒。</span></span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;temp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*p + i)); </span><br><span class="line">        <span class="comment">// p是一个指向数组(并非指向数组第一个元素)的指针，*p就是取出该指针对应的内容，也就是数组temp，即*p=temp，而temp又是数组第一个元素的地址，可以当作指针，并进行指针运算。</span></span><br><span class="line">        <span class="comment">//注意，此时*(*p) = *(temp) = 数组temp的第一个元素.有点嵌套指针的意味了！</span></span><br><span class="line">        <span class="comment">//于是，上述输出也可写成: printf(&quot;%d\n&quot;,(*p)[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>小甲鱼课后作业：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[<span class="number">5</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;FishC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Five&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Star&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Good&quot;</span>,</span><br><span class="line">        <span class="string">&quot;WoW&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> *(*p)[<span class="number">5</span>] = &amp;<span class="built_in">array</span>;  <span class="comment">//定义指向包含5个指针的数组的指针，也就是说这个数组的类型是字符指针类型，故定义相同类型(char *)的数组指针</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; *(*(*p+i)+j) != <span class="string">&#x27;\0&#x27;</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,*(*(*p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此处<code>p</code><strong>实际上是指向包含5个指针的数组，最好写成char<em> (</em>p)[5] = array;</strong></p><h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>观察下述代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array is %p\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array +1 is %p\n&quot;</span>,<span class="built_in">array</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>输出结果是：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array is 0xbfc34320<span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>+1 is 0xbfc34334</span><br></pre></td></tr></table></figure><br>由此得出，二维数组的数组名指向包含5个元素的数组(也就是第一行元素所构成的数组)，<strong>二维数组名实际上就是数组指针</strong>！！！<br>同时也可明白，<code>array + 1</code>则指向第二行构成的数组，即此处的<code>array +1</code>相当于前述的<code>p</code>.   </p><p>二维数组名也可赋值给数组指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>] = <span class="built_in">array</span>; <span class="comment">// p指向第一行元素构成的数组</span></span><br><span class="line">    <span class="type">int</span> (*n)[<span class="number">3</span>] = <span class="built_in">array</span> + <span class="number">1</span>;<span class="comment">// n指向第二行元素构成的数组</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*p)[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*n)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p); <span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,<span class="built_in">array</span>);<span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;(*<span class="built_in">array</span>)); <span class="comment">// 输出第一行元素构成的数组的地址。(注意，并非数组的第一个元素，尽管两者数值上相等。)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p); <span class="comment">//输出第一行元素构成的数组的第一个元素的地址。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**(p+<span class="number">1</span>));<span class="comment">// p是第一行元素构成的数组的地址，(p+1)则是第二行元素构成的数组的地址。</span></span><br><span class="line">    <span class="comment">//因为二维数组在内存中也是线性存储的，p+1表示指针往后移3*4=12个字节，也就是第二行元素构成的数组的地址。</span></span><br><span class="line">    <span class="comment">//即p+1指向第二行元素构成的数组。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="void指针与NULL指针"><a href="#void指针与NULL指针" class="headerlink" title="void指针与NULL指针"></a>void指针与NULL指针</h3><p>void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，<strong>任何类型的指针都可以赋值给void指针。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;num;</span><br><span class="line">    <span class="type">char</span> *n = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *ye;</span><br><span class="line"></span><br><span class="line">    ye = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ye:%p p:%p\n&quot;</span>,ye,p);</span><br><span class="line">    ye = n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ye:%p n:%p\n&quot;</span>,ye,n); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>于是，又引出几个问题：</p><ol><li>void指针如何取值？编译器怎么知道？<ul><li>所以，强制转换符<code>(强制转换类型 *)</code>又出现了。</li></ul></li><li>对于 void指针 <code>p</code>，<code>p + 1</code>移动多少个字节？<ul><li>由于编译器不知道其指向的数据类型，故只移动一个字节。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ye:%d\n&quot;</span>,*((<span class="type">int</span> *)ye));  </span><br></pre></td></tr></table></figure>NULL指针，即空指针，不指向任何一个地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空指针的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NULL ((void *)0)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;  <span class="comment">//定义空指针，解引用(取值)的话程序会报错。</span></span><br><span class="line"><span class="comment">//也可以写成 int *p = (void *)0 ;</span></span><br><span class="line"><span class="type">int</span> *m; <span class="comment">//还未初始化，称为野指针。</span></span><br></pre></td></tr></table></figure>注意，是NULL而不是NUL（在ASCII表中）。</li></ul><ol><li>NULL用于指针和对象，表示控制，指向一个不被使用的地址。</li><li>NUL(‘\0’)表示字符串的结尾。</li></ol></li></ol><p>小甲鱼S1E24：指针和二维数组第5题出现了<code>(int (*)[3])</code>强制类型转换符。具体代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">array</span>[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> (*p)[<span class="number">3</span>] = (<span class="type">int</span> (*)[<span class="number">3</span>])&amp;<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>(int (*)[3])&amp;array</code>等号右边强制将 array 这个一位数组重新划分成3*3的二维数组，p等于二维数组。这与前面第6条所说：<code>二维数组名就是数组指针</code>相呼应。小甲鱼的答案有点问题，p并不是指向二维数组，p就是二维数组名，指向二维数组第一行元素构成的数组。</p><h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;  <span class="comment">//此即指向指针的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证是否指向指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n*pp = %p&quot;</span>,p,*pp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那指向指针的指针有啥用呢？观察如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *cBooks[] = &#123;</span><br><span class="line">        <span class="string">&quot;C primer plus&quot;</span>,</span><br><span class="line">        <span class="string">&quot;带你学C带你飞&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C与指针&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> **charm;</span><br><span class="line"></span><br><span class="line">    charm = &amp;cBooks[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,*charm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由此可以看出，指向指针的指针至少有以下两个好处：</p><ul><li>避免重复分配内存；</li><li>只需对一处进行修改.</li></ul><h3 id="指向指针的指针与二维数组"><a href="#指向指针的指针与二维数组" class="headerlink" title="指向指针的指针与二维数组"></a>指向指针的指针与二维数组</h3><p>观察如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> **p = <span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(*(p+i)+j));   <span class="comment">//对应着case one</span></span><br><span class="line">        <span class="comment">//printf(&quot;%d&quot;,*(*(array+i)+j));  //对应case two</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Case one:</p><blockquote><p>由于p是一个指针，故p+i就是指针移动<code>i</code>个<code>int</code>数据类型所占的字节。例如，i = 1,则p+1就是第一行元素构成数组的地址+4，如果再取值<code>*</code>,由于找不到对应的内容(因为无论是整个数组地址还是数组第一个元素的地址，数值上都等于数组第一个元素的地址，且二维数组的行并不一定在内存中是连续存储的。）因此，使用错误的指针类型可能导致对内存的错误访问，从而触发段错误<code>sgementation default</code>。</p></blockquote><p>Case two:</p><blockquote><p>array可行，因为array本身可看作数组指针，array+1就是移向下一行。</p></blockquote><p>因此，要想正确输出，需将上述代码改为如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = <span class="built_in">array</span>;  <span class="comment">//利用数组指针</span></span><br></pre></td></tr></table></figure><br>这里值得注意的是：</p><ol><li>因为array实际上是第一行元素的构成的数组的地址，<code>[num]</code>中<code>num</code>必须要和该数组元素个数相等。p指向一个4个元素的数组，则<code>p + 1</code>移动<code>sizeof(int) * 4</code>个字节。而如果是<code>*p</code>,此时<code>*p</code>是指向第一行元素的构成的数组的第一个元素，此时<code>*p + 1</code>移动<code>sizeof(int)</code>个字节。</li><li>由上可见，<strong>正如第2条最后所说，指针所指向的数据类型决定指针的跨度</strong>。</li></ol><p>小试牛刀：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="string">&quot;How are you?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;I&#x27;m fine, thanks&quot;</span>,</span><br><span class="line">        <span class="string">&quot;and you?&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span>* (*p)[<span class="number">4</span>]  = &amp;<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(*p)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Ps:B站这一节课有弹幕指出：可以写成<code>(*p)[3][4] = &amp;array</code>,这个其实相当于定义了一个指向二维数组的指针。代码可修改如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>][<span class="number">4</span>] = &amp;<span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,*(*(*p+i)+j)); <span class="comment">//由于p指向整个二维数组，故*p就是二维数组，指向二维数组第一行元素构成的数组，这样也就弱化为指向数组的指针了，同前述第6节。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="常量和指针"><a href="#常量和指针" class="headerlink" title="常量和指针"></a>常量和指针</h3><p>常量：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">520</span>, <span class="string">&#x27;A&#x27;</span>, <span class="params">...</span></span><br></pre></td></tr></table></figure><br>常变量:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">//这样使得a只能读，不能修改，相当于常量，但不是常量.</span></span><br></pre></td></tr></table></figure><br>定义指向常量的指针(<strong>区别于后续所讲常量指针</strong>):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;num;  <span class="comment">//定义指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针指向的值，则会发生错误</span></span><br><span class="line">*p = <span class="number">1250</span>;</span><br><span class="line"><span class="comment">//error: assignment of read-only location &#x27;*p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针的值，这是允许的，相当于该指针不指向常量num.</span></span><br><span class="line"><span class="type">int</span> cnum = <span class="number">250</span>;</span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//编译通过。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时如果改变p指向的值，则报错：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//但是，我们如果修改cnum的值：</span></span><br><span class="line">cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功。</span></span><br></pre></td></tr></table></figure><br>指向常量的指针-总结：</p><ul><li>指针可以修改为指向不同的常量</li><li>指针可以修改为指向不同的变量</li><li>可以通过解引用来读取指针指向的数据</li><li>不可以通过解引用修改指针指向的数据</li></ul><p>那什么是常量指针呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num; <span class="comment">//定义指向非常量的常量指针</span></span><br></pre></td></tr></table></figure><br>特性：</p><ul><li>指针本身值不可改变，指向的值可修改。</li><li><strong>典型例子就是数组名</strong>。</li></ul><p>定义指向非常量的常量指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指向的值：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改本身值：</span></span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//报错：error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><br>如果定义一个指向常量的常量指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;cnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此时既修改指针的值，又修改指针所指向的值，则会报两个错：</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line">p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error:error: assignment of read-only location &#x27;*p&#x27;;</span></span><br><span class="line"><span class="comment">// error:error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><br>可以看出其特点：</p><ul><li>指针本身值不可改变，指向的值也不可修改。</li></ul><p>但有趣的一点是，如果你定义了指向常量的常量指针，但接受的地址不是常量，还是可以通过改变该非常量来修改指针所指向的值的。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line">num = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出111.</span></span><br></pre></td></tr></table></figure><br>又进一步引出：指向 “指向常量的常量指针” 的指针。<br>看到名字别害怕，<strong>去掉定语，也即指向指针的指针</strong>。</p><blockquote><p>要记住:一般来说，<strong>要指向 “常量指针”，自己也必须是指向常量的指针。</strong><br>但如果自己不是指向常量的常量指针也可以的，不过会有<code>warning</code>, 后面详细介绍了<code>const的约束对象</code>，理解将会更加深刻。</p></blockquote><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> **  pp = &amp;p; <span class="comment">//定义指向 “常量指针” 的指针</span></span><br><span class="line"><span class="comment">//上行代码也可以写成（但不推荐）：</span></span><br><span class="line"><span class="comment">//int **p = &amp;p;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证pp指向p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pp = %p, &amp;p = %p\n&quot;</span>,pp,&amp;p);</span><br><span class="line"><span class="comment">//验证*pp == p == &amp;num</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pp = %p, p = %p,&amp;num = %p\n&quot;</span>,*pp,p,&amp;num);</span><br><span class="line"><span class="comment">//验证**pp == *p == num;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**pp = %d, *p = %d, num = %d\n&quot;</span>,**pp,p,num);</span><br></pre></td></tr></table></figure></p><p>小甲鱼S1E27：常量和指针， 关于<code>const的约束对象</code>：<br>请问在下边声明中，const 限制的是 q、*q 还是 **q？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> *q = &amp;p;</span><br><span class="line"></span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>答： 第一个const限制<code>**q</code>(即指针的两次解引用，可以理解为num,但不是num.因为num如果是<code>int num = 250</code>,那么num还是可以修改的，而<code>**q</code>则是不可以的。),第二个const限制<code>*q</code>(同上述理);</p><p>记住一点：<strong>const 永远限制紧随着它的标识符</strong>。那么，如果想要使用 const 同时限制 q、*q 和 **q，应该怎么做？</p><blockquote><p>const int * const * const p; 或者int const * const * const p; 因为<code>const *p</code>等价于 <code>int const *p</code>; 但一般为了可读性，就不写成<code>int const *p</code>,但<code>int const *p</code>更能体现这句话—-const 永远限制紧随着它的标识符.</p></blockquote><p>于是又有人问了，<code>const int const **p</code>; 限制了啥？</p><blockquote><p>其实只限制了<code>**p</code>.</p></blockquote><p>重点：限制了谁谁就变可读了，不能修改（也就不是可修改的左值了）。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数初体验"><a href="#函数初体验" class="headerlink" title="函数初体验"></a>函数初体验</h3><ol><li>C语言程序编译的时候是从上至下，执行的时候是从main()函数开始的。</li><li>void函数不返回任何值，因此不需要加<code>return xxx  ;</code></li><li>养成好习惯：要使用某个函数<code>int func()</code>，先进行声明<code>int func();</code>,千万别丢了分号<code>;</code>.<br>函数声明时，既可带上参数名，也可不带。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>如果定义一个与标准库函数重名的函数，会怎样？<ul><li>重新定义的同名函数会覆盖标准库函数（前提是两者的声明一致，包括返回值和参数类型、个数一致）。</li></ul></li></ol><h3 id="参数和指针"><a href="#参数和指针" class="headerlink" title="参数和指针"></a>参数和指针</h3><ol><li><p>传值和传址<br>观察下列两个代码：<br><strong>传值：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line">    swap(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><blockquote><p>交换前: x = 3, y = 5<br>交换后: x = 3, y = 5</p></blockquote><p><strong>传址：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line">    swap(&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后: x = %d, y = %d\n&quot;</span>,x,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><blockquote><p>交换前: x = 3, y = 5<br>交换后: x = 5, y = 3</p></blockquote></li></ol><p>   为啥结果会不同呢？<br>   因为函数swap(int x, int y)会给x,y单独在内存中找两段储存空间(可理解为局部变量)，<strong>存放传进来的值</strong>，对原来地址上的值无影响。如果传给函数的本就是地址，则函数内部调用时，就是直接对原来地址上的值进行操作。</p><ol><li>传数组<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_array</span><span class="params">(<span class="type">int</span> b[])</span>; <span class="comment">//由于传递数组本质是传递数组第一个元素地址，此处可以不写数组元素个数。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_array</span><span class="params">(<span class="type">int</span> b[])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof b: %d\n&quot;</span>,<span class="keyword">sizeof</span>(b)); <span class="comment">//由于传递的是一个地址，也就是指针，取决于操作系统。我的操作系统是64位，故返回8。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof a: %d\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    get_array(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p>可变参数<br>首先需要调用<code>stdarg.h</code>头文件，具体实现原理可见<a href="https://www.cnblogs.com/clover-toeic/p/3736748.html">可变参数详解</a>，常见用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">VarArgFunc</span><span class="params">(<span class="type">int</span> dwFixedArg, ...)</span>&#123; <span class="comment">//以固定参数的地址为起点依次确定各变参的内存起始地址</span></span><br><span class="line"></span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;  <span class="comment">//定义va_list类型的指针pArgs，用于存储参数地址</span></span><br><span class="line"></span><br><span class="line">    va_start(pArgs, dwFixedArg); <span class="comment">//初始化pArgs指针，使其指向第一个可变参数。该宏第二个参数是变参列表的前一个参数，即最后一个固定参数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dwVarArg = va_arg(pArgs, <span class="type">int</span>); <span class="comment">//该宏返回变参列表中的当前变参值并使pArgs指向列表中的下个变参。该宏第二个参数是要返回的当前变参类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若函数有多个可变参数，则依次调用va_arg宏获取各个变参</span></span><br><span class="line"></span><br><span class="line">    va_end(pArgs);  <span class="comment">//将指针pArgs置为无效，结束变参的获取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Code Block using variable arguments */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_arg</span><span class="params">(<span class="type">int</span> n, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func_arg</span><span class="params">(<span class="type">int</span> n, ...)</span>&#123;</span><br><span class="line">    va_list pargs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pargs,n);</span><br><span class="line">    <span class="type">int</span> i = va_arg(pargs, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    func_arg(<span class="number">10</span>);<span class="comment">//打印固定参数i堆栈上方一个内容(垃圾值)</span></span><br><span class="line">    func_arg(<span class="number">10</span>,<span class="number">5</span>);<span class="comment">//打印固定参数i堆栈上方一个内容(5)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 原理图如下所示：</p><div align="center"><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/可变参数堆栈.png" width="80%"></div><p><strong>小试牛刀</strong>：尝试实现sum()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,sum = <span class="number">0</span>;</span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pArgs,n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">        sum += va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(pArgs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>勇攀高峰</strong>：尝试自己模拟实现 printf 格式化输出的基本功能，基本要求如下：</p><ul><li>输出第一个参数中除了格式化占位符外的所有字符</li><li>实现 %d 的格式化输出</li><li>实现 %c 的格式化输出</li><li>实现 %s 的格式化输出</li><li>实现 myprintf 函数返回打印了多少字符</li><li><p><strong>全程仅能使用 putchar 唯一一个标准库函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span>* str,...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printstr</span><span class="params">(<span class="type">char</span>* str)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printstr</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(str[i++]);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printint</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> dec = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = num;</span><br><span class="line">    <span class="keyword">while</span> (temp &gt; <span class="number">9</span>)&#123;</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">        dec *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dec &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(num/dec + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        count++;</span><br><span class="line">        num %= dec ;</span><br><span class="line">        dec /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span>* str,...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> carg;</span><br><span class="line">    <span class="type">char</span> *sarg ;</span><br><span class="line">    <span class="type">int</span> darg;</span><br><span class="line"></span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    va_start(pArgs,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str[i++]);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (str[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:&#123;</span><br><span class="line">                    sarg = va_arg(pArgs,<span class="type">char</span>*);</span><br><span class="line">                    num += printstr(sarg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:&#123;</span><br><span class="line">                    carg = va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">                    <span class="built_in">putchar</span>(carg);</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:&#123;</span><br><span class="line">                    darg = va_arg(pArgs,<span class="type">int</span>);</span><br><span class="line">                    num += printint(darg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(pArgs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    i = myprintf(<span class="string">&quot;Hello %s\n&quot;</span>, <span class="string">&quot;FishC&quot;</span>);</span><br><span class="line">    myprintf(<span class="string">&quot;共打印了%d个字符(包含\\n)\n&quot;</span>, i);</span><br><span class="line">    i = myprintf(<span class="string">&quot;int: %d, char: %c\n&quot;</span>, <span class="number">-520</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    myprintf(<span class="string">&quot;共打印了%d个字符(包含\\n)\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="指针函数与函数指针"><a href="#指针函数与函数指针" class="headerlink" title="指针函数与函数指针"></a>指针函数与函数指针</h3><ol><li>指针函数<br>定义：使用<strong>指针变量作为函数的返回值</strong>的函数，就是指针函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">pointer</span><span class="params">()</span>; <span class="comment">//写成 char* pointer();可能更好理解，但遵循一般习惯，就这样吧。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">pointer</span><span class="params">()</span>&#123;</span><br><span class="line"> ...;</span><br><span class="line"> <span class="keyword">return</span> 字符指针;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>需要特别注意的是：<strong>不要返回局部变量的指针！！！</strong><br>举例如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_word</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_word</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要写成下面这样，因为函数一结束，所有变量值会被清理掉，虽然返回了变量的地址，但该地址上啥值也没有。</span></span><br><span class="line"><span class="comment">// char *get_word(char c)&#123;</span></span><br><span class="line"><span class="comment">//     char str1[] = &quot;Apple&quot;;</span></span><br><span class="line"><span class="comment">//     char str2[] = &quot;Banana&quot;;</span></span><br><span class="line"><span class="comment">//     char str3[] = &quot;Cat&quot;;</span></span><br><span class="line"><span class="comment">//     char str4[] = &quot;Dog&quot;;</span></span><br><span class="line"><span class="comment">//     char str5[] = &quot;None&quot;;</span></span><br><span class="line"><span class="comment">//     switch (c)&#123;</span></span><br><span class="line"><span class="comment">//         case &#x27;A&#x27;: return str1;</span></span><br><span class="line"><span class="comment">//         case &#x27;B&#x27;: return str2;</span></span><br><span class="line"><span class="comment">//         case &#x27;C&#x27;: return str3;</span></span><br><span class="line"><span class="comment">//         case &#x27;D&#x27;: return str4;</span></span><br><span class="line"><span class="comment">//         default: return str5;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要查询的字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,get_word(c));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可能又有人问了，为啥可以直接返回字符串”Apple”…哪些呢？<br>参考ChatGPT回答:<div align="center"><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/指针函数与函数指针_局部变量的指针.jpg" width="90%"></div></li><li>函数指针<br>定义：指向函数的指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> num*num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>); <span class="comment">//定义函数指针，此处第一个int取决于所指向的函数的返回值，第二个int取决于函数的输入参数。就跟函数定义时相同即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化函数指针</span></span><br><span class="line">fp = square;     <span class="comment">//也可以写成fp = &amp;square; 但没必要，因为一般来说，函数编译后，函数名就是函数的地址。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在主函数中通过函数指针调用函数</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*fp)(num));</span><br><span class="line"><span class="comment">//其实也可以写成 printf(&quot;%d&quot;,fp(num)); 但为了与函数混淆，还是写成上面那种形式比较好。</span></span><br></pre></td></tr></table></figure>需要注意的就是函数编译后，函数名就是函数指针。</li><li>函数指针作为参数<br>举个栗子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数指针作为参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1 ,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 + 5 = %d\n&quot;</span>,calc(add,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3 - 5 = %d\n&quot;</span>,calc(sub,<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数指针作为返回值<br>接着上节，举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span>))(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">//定义一个参数为char类型，返回值为函数指针的函数.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1 ,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为返回值</span></span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span> op))(<span class="type">int</span> num1, <span class="type">int</span> num2)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> add;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入计算表达式:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;num1,&amp;op,&amp;num2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>,num1,num2,calc(select(op),num1,num2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面，我们可以发现，定义返回值类型为函数指针,参数类型为字符的函数，且所返回的函数指针指向的函数接收两个int类型参数且返回值为int类型的操作为： <code>int (*func(int))(int, int);</code>.<br>函数拓展 &gt;&gt; <code>snprintf函数</code>，函数详解-&gt; <a href="https://fishc.com.cn/thread-68870-1-1.html">传送门</a>.<br>举个栗子😊：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">42</span>;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//将整数42以16进制数的形式写入字符数组</span></span><br><span class="line">    <span class="comment">//42(10) == 2a(16)</span></span><br><span class="line">    <span class="built_in">snprintf</span>(<span class="built_in">array</span>,<span class="number">3</span>,<span class="string">&quot;%02x&quot;</span>,c);</span><br><span class="line">    <span class="comment">//打印字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">array</span>); <span class="comment">//  输出结果为2a，从而印证上述说法.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><ol><li><p>局部变量<br>局部变量（Local Variables）是指在特定范围内声明和使用的变量。这个特定的范围通常是在一个函数或者一个代码块内部。<br>特定范围中一个函数的情况很常见，对于代码块内部，下面举一例进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;before, i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;after, i = %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环内部的i只作用于该循环，且循环内部调用的i只能是<code>int i = 0</code>这里定义的。在<code>for</code>循环外面调用的i就是<code>int i = 520;</code>这里定义的！！！<br>如下图所示：<br><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/循环内局部变量作用范围.jpg" alt="循环内局部变量"></p><blockquote><p>不过要注意的是，C99才允许上述在<code>for</code>语句中定义变量。因为C99允许在使用时才定义变量，而不是一开始在最上面定义变量。</p></blockquote></li><li><p>全局变量<br>在函数里面定义的，我们叫局部变量；在函数外部定义的，我们叫外部变量，也叫做<strong>全局变量</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   a();</span><br><span class="line">   b();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>如果不对全局变量进行初始化，那么它会自动初始化为0</strong>。</li><li>如果在函数的内部存在一个与全局变量同名的局部变量，编译器并不会报错，而是在函数中屏蔽全局变量（也就是说在这个函数中，全局变量不起作用)。</li></ul><p>举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">   a = <span class="number">880</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line">   func();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>,a+b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a + b = <span class="number">520</span></span><br><span class="line">a + b = <span class="number">1000</span></span><br><span class="line">a + b = <span class="number">1400</span></span><br></pre></td></tr></table></figure><p>一般来说编译器不允许先使用变量再定义，否则会报错；<br>但是如果我们使用关键字<code>extern</code>，则是可以的。该关键字的功能就是告诉编译器，我是定义了这个变量的，只不过在后面；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   func();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="作用域与链接属性"><a href="#作用域与链接属性" class="headerlink" title="作用域与链接属性"></a>作用域与链接属性</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域包括以下几种类型：</p><ul><li>代码块作用域</li><li>文件作用域</li><li>原型作用域</li><li>函数作用域</li></ul><div class="tabs" id="作用域"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="作用域-1">代码块作用域</button><button type="button" class="tab " data-href="作用域-2">文件作用域</button><button type="button" class="tab " data-href="作用域-3">原型作用域</button><button type="button" class="tab " data-href="作用域-4">函数作用域</button></ul><div class="tab-contents"><div class="tab-item-content active" id="作用域-1"><p>在代码块中定义的变量，具有代码块作用域。作用范围是从变量定义的位置开始，到标志该代码块结束的右大括号(})处。<br>另外，尽管函数的形式参数不在大括号内定义，但其同样具有代码块作用域，隶属于包含函数体的代码块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">120</span>;</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">130</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">130</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="作用域-2"><p>任何在<strong>代码块之外声明的标识符</strong>都具有文件作用域，作用范围是从它们声明位置开始，到文件的结尾处结束。另外，函数名也具有文件作用域，因为函数名本身也在代码块之外。</p><blockquote><p>定义了一定是声明了！！！典型的就是全局变量的定义，故作用范围是从定义的位置开始，到文件结尾处结束！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> count;   <span class="comment">//全局变量声明。当然也可以直接定义，例如在main函数前面写 int count = 0;</span></span><br><span class="line">    func();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main, count = %d\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func, count = %d\n&quot;</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In func, count = <span class="number">1</span></span><br><span class="line">In main, count = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>很显然，如果没有声明(<code>void func()</code>和<code>extern int count</code>)，那么编译器也不知道后面会有func和count，就报个错先！<br>进一步，可以看出，具有文件作用域的标识符包括<strong>函数名和全局变量</strong>！</p></div><div class="tab-item-content" id="作用域-3"><p>原型作用域(prototype scope)<strong>只适用于那些在函数原型中声明的参数名</strong>。我们知道，函数在声明的时候可以不写参数的名字（但参数类型是必须要写上的），其实尝试一下还可以发现，<strong>函数原型</strong>的参数名还可以随便写一个名字，不必与<strong>函数定义</strong>时的形式参数相匹配（当然，这样做毫无意义)。之所以允许这么做，是因为原型作用域起了作用。<br><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/原型作用域.jpg" alt="原型作用域"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型（亦称为函数声明）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="作用域-4"><p>函数作用域只适用于语句标签（而语句标签用于goto语句）。使用规则：一个函数的所有语句标签必须唯一。<br>goto语句的作用域是一个函数的大小，而不是一个代码块。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h4 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h4><p>啥是链接？可能刚开始比较疑惑，那就看看C语言源代码是如何编程可执行文件(.exe)的吧！—&gt;传送门:[]<br>链接属性分类：</p><ul><li>external（外部属性）：多个文件中声明的同名标识符表示同一个实体。</li><li>internal（内部属性）：单个文件中声明的同名标识符表示同一个实体。</li><li>none（空链接属性）：声明的同名标识符中被当作不同独立的实体。比如，函数的局部变量，因为它们被当作独立不同的实体，所以不同函数间同名的局部变量并不会发生冲突。</li></ul><p>特点：</p><ul><li><strong>只有具备文件作用域的标识符才能拥有external或internal的链接属性</strong>，其他作用域的标识符都是none属性。</li><li>默认情况下，具备文件作用域的标识符拥有external属性。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">a</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   a();</span><br><span class="line">   b();</span><br><span class="line">   c();</span><br><span class="line">   b();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>static</strong>关键字对<strong>链接属性</strong>的修改：</p><ol><li>使用static关键字修改链接属性，<strong>只对具有文件作用域的标识符生效</strong>（对于拥有其他作用域的标识符是另一种功能）。(当然只是对链接属性进行了修改，<strong>作用域还是没变</strong>！！！)</li><li><strong>链接属性只能修改一次</strong>，也就是说，一旦将标识符的链接属性变为internal,就无法再变回external了。</li></ol><p>这样做的好处就是保护全局变量，以免在其他文件中被修改！</p><p>本节作用域与链接属性是从空间角度分析的，下面将从时间角度作为切入点！！！</p><h3 id="生存期与存储类型"><a href="#生存期与存储类型" class="headerlink" title="生存期与存储类型"></a>生存期与存储类型</h3><h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>C语言拥有两种生存期：</p><ul><li>静态存储期(static storage duration)</li><li>自动存储期(automatic storage duration)</li></ul><div class="tabs" id="生存期"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="生存期-1">静态存储期</button><button type="button" class="tab " data-href="生存期-2">自动存储期</button></ul><div class="tab-contents"><div class="tab-item-content active" id="生存期-1"><p><strong>具有文件作用域的变量</strong>属于静态存储期，函数也属于静态存储期。属于静态存储期的变量在程序执行期间将一直占据存储空间，<strong>直到程序关闭才释放</strong>。</p></div><div class="tab-item-content" id="生存期-2"><p><strong>具有代码块作用域的变量</strong>一般情况下属于自动存储期。属于自动存储期的变量在<strong>代码块结束时将自动释放存储空间</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h4><p>C语言提供了五种不同的存储类型：</p><ul><li>atuo(default)</li><li>register</li><li>static</li><li>typedef</li></ul><div class="tabs" id="存储类型"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="存储类型-1">自动变量(auto)</button><button type="button" class="tab " data-href="存储类型-2">寄存器变量(register)</button><button type="button" class="tab " data-href="存储类型-3">静态局部变量(static)</button><button type="button" class="tab " data-href="存储类型-4">typedef</button></ul><div class="tab-contents"><div class="tab-item-content active" id="存储类型-1"><p><strong>默认适用对象</strong>：函数中的形参、局部变量及复合语句中定义的局部变量等；<br><strong>特性</strong>：拥有代码块作用域、自动存储期和空连接属性(None);<br>在代码块中声明的变量默认的存储类型就是<code>auto</code>，不过auto可以省略，平常我们写的时候就省略了。<br>不过当强调局部变量屏蔽全局变量这一做法时，可以在局部变量前加上auto。</p></div><div class="tab-item-content" id="存储类型-2"><p><strong>声明</strong>：register int i;…<br><strong>特性</strong>：</p><ul><li>代码块作用域、自动存储期和空链接属性；</li><li>不能通过取址运算符(&amp;)获得该变量的地址！！！</li></ul><p>将一个变量声明为寄存器变量，那么该变量就<strong>有可能</strong>被存放于位于CPU的寄存器。为啥说有可能呢？因为CPU的寄存器空间十分有限，所以编译器并不会让所有声明为register的变量都放到寄存器中。<br>事实上，有可能所有的register关键字都被忽略，因为编译器有自己的一套优化方法，会权衡哪些才是最常用的变量。在编译器看来，它比你更了解程序。而那些被忽略的register变量，它们会变成普通的自动变量。</p></div><div class="tab-item-content" id="存储类型-3"><p>首先可能有人会好奇，为啥会叫静态局部变量呢？<br>这就对了，因为static作用于全局变量时，是修改其链接属性。那么static作用于局部变量会发生什么奇妙的事情呢？<br>static作用于局部变量会使<strong>局部变量的生存期</strong>由自动存储期变为静态储存期！由此可得其特性：<br><strong>特性</strong>：空链接属性、代码块作用域、静态存储期。<br>举例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>,count);</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">      func();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="存储类型-4"><p>该类型将在结构体章节详细阐述！！！</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>切记：递归一定要有结束条件！<br>基操：实现阶乘<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recursion(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d! = %d&quot;</span>,n,recursion(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>小试牛刀：</p><div class="tabs" id><ul class="nav-tabs"><button type="button" class="tab  active" data-href="-1">汉诺塔</button><button type="button" class="tab " data-href="-2">快速排序</button></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/递归-汉诺塔.jpg" alt="汉诺塔"><br>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>, <span class="type">char</span>, <span class="type">char</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> z)</span>&#123;   <span class="comment">//表示的意义为：从x移到z位置，借助y；</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        func(n<span class="number">-1</span>, x, z, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, x, z);</span><br><span class="line">        func(n<span class="number">-1</span>, y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>,y = <span class="string">&#x27;y&#x27;</span>,z = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input story:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">    func(n,x,y,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="-2"><p><img src="/2023/Study/Computer%20science/%E7%A0%B4%E5%B1%80/递归-快速排序.jpg" alt="快速排序"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> *p,  <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = end;</span><br><span class="line">    <span class="type">int</span> judge = p[(start+end)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (; p[i] &lt; judge; i++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; p[j] &gt; judge; j--)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = p[i];</span><br><span class="line">        p[i] = p[j];</span><br><span class="line">        p[j] = temp;</span><br><span class="line">        i++;    <span class="comment">//特别要注意，比较完之后要向中间靠拢，否则遇见p[i] == p[j]的情况就会陷入死循环！</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后i和j一定是相邻的！因为i走过的必定是满足p[i] &lt; judge，也就不可能满足p[j] &gt; judge了；同理，j走过的必定不可能满足i，故i,j最后会相邻，且i &gt; j!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; start)&#123;</span><br><span class="line">        quick_sort(p, start, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; end)&#123;</span><br><span class="line">        quick_sort(p, i, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">388</span>,<span class="number">458</span>,<span class="number">253</span>,<span class="number">245</span>,<span class="number">356</span>,<span class="number">356</span>,<span class="number">122</span>,<span class="number">223</span>,<span class="number">245</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, length;</span><br><span class="line"></span><br><span class="line">    length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    quick_sort(<span class="built_in">array</span>, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the sorted result is\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= length; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><p>在之前所学中，变量一经定义，其内存大小就不能再更改了！那么有什么办法能让C语言更灵活地管理内存资源呢？<br>答案是有的，需要借助几个库函数，这几个库函数在<code>stdlib.h</code>这个头文件中！</p><h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><br>malloc函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的指针。不过要注意，申请的这块空间并没有被“清理”（初始化为0），所以它上面的数据是随机的（就与局部变量一样）。</p><ul><li>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针(void*),所以它可以被转换成任何类型的数据：</li><li>如果函数调用失败，返回值是NULL。</li><li>另外，如果size参数设置为O,返回值也可能是NULL,但这并不意味着函数调用失败。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num is %d\n&quot;</span>,*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><br>由于malloc函数申请的空间位于内存的堆上，如果不主动释放它，那么它会一直存在直到程序结束！<br>所以以后写程序，<code>malloc</code>和<code>free</code>要成对！<br>故上面程序应该为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input number:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num is %d\n&quot;</span>,*ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);    <span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>内存泄漏指的是在程序运行过程中，动态分配的内存空间没有被正确释放的情况。导致内存泄漏主要有以下两种情况：</p><ol><li>隐式内存泄漏(即用完内存块没有及时使用free函数释放掉)；</li><li>丢失内存地址；</li></ol><p>丢失内存地址就是说把原本指向动态申请的内存地址的指针指向别的地方了。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">ptr = &amp;num; <span class="comment">//丢失内存地址</span></span><br></pre></td></tr></table></figure></p><h4 id="申请任意尺寸的内存空间"><a href="#申请任意尺寸的内存空间" class="headerlink" title="申请任意尺寸的内存空间"></a>申请任意尺寸的内存空间</h4><p>malloc不仅可以申请基本类型数据的空间，还可以申请一块任意的内存空间。对于后者，由于申请得到的空间是连续的，通常采用数组来进行索引。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于malloc并不会初始化申请的内存空间，所以需要自己进行初始化。当然可以写个循环来做这件事，但不建议这么做，标准库提供了更加高效的函数：<code>memset</code>。以mem开头的函数被编入字符串标准库，函数的声明包含在string.h这个头文件中.—&gt;<a href="https://fishc.com.cn/thread-80241-1-1.html">memset函数传送门</a>.</p><blockquote><p>除了memset函数之外，类似的还有memcpy，memmove，memcmp等等，可见小甲鱼函数快查.—&gt;<a href="https://fishc.com.cn/thread-66397-1-1.html">传送门</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>,i,ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的同学可能发现了，这样每次写完<code>malloc</code>，还要再写<code>memset</code>，略显繁琐，于是C语言提供了<code>calloc</code>函数一步实现上述功能！</p><h4 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></p><p>calloc函数在内存中动态地申请nmemb个长度为size的连续内存空间(即申请的总空间尺寸为nmemb*size)，这些内存空间全部被初始化为0。</p><p>如果函数调用成功，会返回一个指向申请的内存空间的指针，由于返回类型是void指针(void*)，所以它可以被转换成任何类型的数据：如果函数调用失败，返回值是NULL。如果nmemb或size参数设置为O，返回值也可能是NULL，但这并不意味着函数调用失败。</p><p>calloc函数与malloc函数的一个重要区别是：calloc函数在申请完内存后，自动初始化该内存空间为0，而malloc函数不进行初始化操作，里边数据是随机的。因此，下面两种写法是等价的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">8</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(ptr, <span class="number">0</span>, <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p><h4 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h4><p>在现实操作中，我们会经常碰到内存空间不足的问题，需要扩展，此时可以借<code>malloc</code>和<code>memccpy</code>进行扩充：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr1;</span><br><span class="line">    <span class="type">int</span> *ptr2;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ptr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>((num*<span class="number">2</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr2, ptr1, num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    ptr2[num] = <span class="number">5201314</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr2[%d] == %d\n&quot;</span>, num, ptr2[num]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr2[%d] == %d\n&quot;</span>,i, ptr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="built_in">free</span>(ptr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的操作比较繁琐，还好C语言有相应的库函数，没错，就是<code>realloc</code>!<br>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></p><p>不过需要注意以下几点：</p><ul><li>realloc函数将ptr指向的内存空间大小修改为size字节。</li><li>如果新分配的内存空间比原来的大，则旧内存块的数据不会发生改变：如果新分配的内存空间比原来的小，则可能导致数据丢失，请慎用。</li><li>该函数将移动内存空间的数据并返回新的指针。</li><li>如果ptr参数为NULL，那么调用该函数就相当于调用malloc(size)。</li><li>如果size参数为0，并且ptr参数不为NULL,那么调用该函数就相当于调用free(ptr)。</li><li>除非ptr参数为NULL,否则，ptr的值必须由先前调用malloc、calloc或realloc函数返回。</li></ul><p>编写一个程序，不断地接收用户输入的整数，直到用户输入-1表示输入结束，将所有数据打印出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;    <span class="comment">//此处必须初始化为NULL，因为realloc()参数中要求了！如前述注意事项最后一点！</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please input number(-1: exit):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        count++;</span><br><span class="line">        ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr,count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        ptr[count<span class="number">-1</span>] = num;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] == %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="顺序读写文件"><a href="#顺序读写文件" class="headerlink" title="顺序读写文件"></a>顺序读写文件</h3><p>本节主要练习那些文件操作函数，见传送门-&gt;<a href="https://fishc.com.cn/thread-66397-1-1.html">C语言函数索引</a><br>常用的，例如：</p><ul><li>fopen();</li><li>fputc()/putc();  (区别于putchar，看着很像)</li><li>fgetc()/getc(); （区别于getchar()）</li><li>fputs();</li><li>fgets();</li></ul><p>这一节还有几个比较有趣的拓展阅读:</p><ul><li><a href="https://fishc.com.cn/thread-91062-1-2.html">如何理解万物皆文件</a></li><li><a href="https://fishc.com.cn/thread-92251-1-2.html">文本流与二进制流的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>土木工程专业课程设计</title>
      <link href="/2023/Resource%20sharing/%E5%9C%9F%E6%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/Resource%20sharing/%E5%9C%9F%E6%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="结构力学课程设计"><a href="#结构力学课程设计" class="headerlink" title="结构力学课程设计"></a>结构力学课程设计</h3><div class="row">    <embed src="结构力学课程设计.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="混凝土楼盖课程设计"><a href="#混凝土楼盖课程设计" class="headerlink" title="混凝土楼盖课程设计"></a>混凝土楼盖课程设计</h3><div class="row">    <embed src="混凝土课程设计.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="房屋结构课程设计"><a href="#房屋结构课程设计" class="headerlink" title="房屋结构课程设计"></a>房屋结构课程设计</h3><div class="row">    <embed src="房屋结构课程设计.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="基础工程课程设计"><a href="#基础工程课程设计" class="headerlink" title="基础工程课程设计"></a>基础工程课程设计</h3><div class="row">    <embed src="基础工程课程设计.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="钢结构课程设计"><a href="#钢结构课程设计" class="headerlink" title="钢结构课程设计"></a>钢结构课程设计</h3><div class="row">    <embed src="钢结构课程设计.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="土木工程施工课程设计"><a href="#土木工程施工课程设计" class="headerlink" title="土木工程施工课程设计"></a>土木工程施工课程设计</h3><div class="row">    <embed src="土木工程施工课程设计.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结构设计杂谈</title>
      <link href="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/"/>
      <url>/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="内力组合相关疑惑"><a href="#内力组合相关疑惑" class="headerlink" title="内力组合相关疑惑"></a>内力组合相关疑惑</h1><p>以框架结构为例，<strong>抗震设计</strong>时，内力组合遵循一下原则：（电脑也是这么算的，具体可以参见<strong>广厦计算结果</strong>）<br>注意：下面 $\gamma _ { GE }$ 取1.2是老规范，新规范是1.3.<br><div class="row">    <embed src="内力组合分析.pdf" width="100%" height="550" type="application/pdf"></div></p><p>关键要义：<strong>在同一个组合下一直算（包括强柱弱梁等内力调整，要在同一个组合内调整），然后最后截面设计时再在不同组合中取最不利的值</strong>。<br>广厦内力组合如下，验证了上面的想法。</p><div align="center"><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/广厦内力组合.jpg" width="90%"></div><h1 id="振型分解反应谱法-弹性分析"><a href="#振型分解反应谱法-弹性分析" class="headerlink" title="振型分解反应谱法(弹性分析)"></a>振型分解反应谱法(弹性分析)</h1><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p><a href="https://coe.ouc.edu.cn/2022/0527/c9093a371372/page.htm">谭启阳老师</a>给我们上钢结构设计课程时讲到了振型分解反应谱法，之前学的不够深入，很多都是半知半解。结合我的一些笔记和理解，现分享如下：<br><div class="row">    <embed src="振型分解反应谱法.pdf" width="100%" height="550" type="application/pdf"></div></p><p>看完上面也就理解了振型参与质量系数$\mu _ { i }$和振型有效质量系数$\sum _ { i = 1 } ^ { j } \mu _ { i }$,其中j表示累加到第j振型。<br>一般第一阶振型的振型参与质量系数在0.85左右，这也是为啥底部剪力法中等效质量取总质量的0.85倍了(如下式)。</p><script type="math/tex; mode=display">G _ { e q } = 0.85 \sum _ { i = 1 } ^ { n } G _ { i }</script><h2 id="具体细节证明"><a href="#具体细节证明" class="headerlink" title="具体细节证明"></a>具体细节证明</h2><h3 id="特征值方程解的问题"><a href="#特征值方程解的问题" class="headerlink" title="特征值方程解的问题"></a>特征值方程解的问题</h3><p>上述推导过程中提到：通过解频率方程 $| K - \omega ^ { 2 } M | = 0$ ，能得到的n个正特征值(可能有重根)和n个线性无关的特征向量。其中为啥一定能得到n个线性无关的特征向量？<br>答：n个互不相同频率对应的特征向量很容易证明线性无关，线性代数书上也有相关证明。那如果n个频率中有重频的话，重频对应的特征向量也线性无关吗？答案是可以找到线性无关的特征向量，也可以找到线性相关的。具体可参考<a href="https://www.zhihu.com/question/625663327/answer/3255480547?utm_id=0"><strong>为什么实对称矩阵相同的特征值对应的特征向量可以线性无关，也可以线性相关？</strong></a></p><h3 id="结构刚度矩阵正定问题"><a href="#结构刚度矩阵正定问题" class="headerlink" title="结构刚度矩阵正定问题"></a>结构刚度矩阵正定问题</h3><p>如何证明<strong>结构的刚度矩阵</strong>的刚度一定是正定的？<br>答：从物理意义方面，可以利用应变能来证明；从数学方面，可以通过结构平衡-几何矩阵互伴定理来证明，具体证明见本博客文章：<strong>力学基础与专业基础</strong>—结构力学—结构平衡-几何互伴定理这一板块。</p><h1 id="底部剪力法-弹性分析"><a href="#底部剪力法-弹性分析" class="headerlink" title="底部剪力法(弹性分析)"></a>底部剪力法(弹性分析)</h1><div class="row">    <embed src="底部剪力法.pdf" width="100%" height="550" type="application/pdf"></div><p>注意底部剪力法的适用范围！</p><h1 id="时程分析法-弹性分析、弹塑性分析"><a href="#时程分析法-弹性分析、弹塑性分析" class="headerlink" title="时程分析法(弹性分析、弹塑性分析)"></a>时程分析法(弹性分析、弹塑性分析)</h1><h2 id="中心差分法"><a href="#中心差分法" class="headerlink" title="中心差分法"></a>中心差分法</h2><div class="row">    <embed src="时程分析-中心差分法.pdf" width="100%" height="550" type="application/pdf"></div><p>从上述资料中可以看出，以线弹性体系为例，有：</p><script type="math/tex; mode=display">\scriptstyle X _ { i + 1 } = ( \frac { M } { \Delta t ^ { 2 } } + \frac { C } { 2 \Delta t } ) ^ { - 1 } \left[ - M \{1\}\ddot { X } _ { g , i } - ( \frac { M } { \Delta t ^ { 2 } } - \frac { C } { 2 \Delta t } ) X _ { i - 1 } - ( K - \frac { 2 M } { \Delta t ^ { 2 } } ) X _ { i } \right]</script><p>当我们给定地震加速度时程曲线(也就已知上式中 $\ddot { X } _ { g , i }$ )，(第0时刻和第-1时刻由上述资料可知是已知的)，就可以求出任意时刻结构体系的位移，也即得到了结构体系的位移时程曲线。</p><h1 id="焊接纵向、横向残余应力的理解"><a href="#焊接纵向、横向残余应力的理解" class="headerlink" title="焊接纵向、横向残余应力的理解"></a>焊接纵向、横向残余应力的理解</h1><ol><li><p>焊接纵向残余应力<br>所谓<strong>纵向</strong>，就是<strong>应力方向与焊缝长度方向平行</strong>。如下图所示。</p><div align="center"><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接纵向残余应力.jpg" width="70%"></div><div align="center"><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接纵向残余应力-1.jpg" width="70%"></div><p>对于是<strong>拉应力还是压应力</strong>，应该这么理解：靠近焊缝的部分，在冷却时，受到两端已经冷却（或者说热影响不大）的区域限制，限制它<strong>收缩</strong>，故在其中产生了拉应力。由于板件<strong>未受外力</strong>，截面必然<strong>平衡</strong>，故两端的纵向残余应力为<strong>压应力</strong>。</p></li><li>焊接横向残余应力<br>所谓<strong>横向</strong>就是<strong>垂直于焊缝长度方向</strong>，例如两块板对接焊，当焊缝<strong>纵向收缩</strong>时，两块板件有向相反反向弯曲的趋势，造成焊缝中部<strong>两端受压，中间受拉</strong>。如下图所示。<div align="center"><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接横向残余应力.jpg" width="70%"></div></li></ol><h1 id="剪力墙按受力特性的分类及其受力特征"><a href="#剪力墙按受力特性的分类及其受力特征" class="headerlink" title="剪力墙按受力特性的分类及其受力特征"></a>剪力墙按受力特性的分类及其受力特征</h1><ol><li><strong>整体墙</strong><br>定义：无洞口的剪力墙或剪力墙上开有一定数量的洞口，但洞口的面积不超过墙体面积的16%，且洞口至墙边的净距及洞口之间的净距大于洞孔长边尺寸时，可以忽略洞口对墙体的影响，这种墙体称为整体剪力墙。<br>受力特征：整体剪力墙的受力状态如同竖向悬臂梁，截面变形后仍符合平面假定，<strong>因而截面应力可按材料力学公式计算</strong>，变形属弯曲型。</li><li><strong>整体小开口墙</strong><br>定义：当剪力墙上所开洞口面积稍大且超过墙体面积的16%时，在水平荷载作用下，这类剪力墙截面上的正应力分布略偏离了直线分布的规律，变成了相当于在整体墙弯曲时的直线分布应力之上叠加了墙肢局部弯曲应力，当墙肢中的局部弯矩不超过墙体整体弯矩的15%时，其截面变形仍接近于整体截面剪力墙，这种剪力墙称之为小开口整体剪力墙。<br>受力特征：<strong>对于小开口剪力墙，其截面变形大体上仍符合平面假定，正应力大体上呈直线分布。为计算方便，力和变形仍按材料力学计算，然后适当修正。</strong>（一般<strong>内力计算</strong>是：将总力矩的85%按材料力学的方法计算墙肢弯矩及轴力，将总力矩的15%按墙肢的刚度进行分配。<strong>位移的计算</strong>：按照整体墙计算，不过考虑到洞口削弱墙体刚度，最终结果要放大20%）</li><li><p><strong>联肢墙</strong><br>定义：当剪力墙沿竖向开有一列或多列较大的洞口时，由于洞口较大，剪力墙截面的整体性已被破坏，剪力墙的截面变形已不再符合平截面假设。这时剪力墙成为由一系列连梁约束的墙肢所组成的联肢墙。<br>受力特征：洞口开得比较大，截面的整体性已经破坏，<strong>横截面上正应力的分布远不是遵循沿一根直线的规律。</strong>但墙肢的线刚度比同列两孔间所形成的连梁的线刚度大得多，每根连梁中部有反弯点，各墙肢单独弯曲作用较为显著，但仅在个别或少数层墙肢出现反弯点。<strong>其变形曲线与整体小开口墙相近，仍以弯曲变形为主</strong>，内力计算宜采用连续化方法，例如<strong>连续连杆法</strong>。<br><code>连续连杆法基本假定</code>:</p><ol><li>连梁反弯点位于跨中，连梁的作用可以用沿高度 均匀分布的连续弹性薄片代替。</li><li>各墙肢的刚度相差不过分悬殊，因而变形曲线相似。</li><li>连梁和墙肢考虑弯曲和剪切变形，墙肢还应考虑轴向变形的影响。</li><li>各墙肢、连梁截面尺寸、材料强度及层高沿剪力墙全高相同。</li></ol><p><strong>基本原理</strong>：运用力法原理，将连梁中点切开，去掉多余约束，建立静定体系。切开后连杆剪力是多余未知力，是一个连续函数。由切开处的变形协调条件建立连杆剪力的微分方程，求解微分方程即得连杆剪力 。将层高范围内的各点剪力积分还原成一根连梁的剪力。各层连梁中点剪力求出后，所有墙肢及连梁内力都可相继求出。</p></li><li><strong>壁式框架</strong><br>定义：当剪力墙的洞口尺寸较大，墙肢宽度较小，连梁的线刚度接近于墙肢的线刚度时，剪力墙的受力性能已接近于框架，这种剪力墙称为壁式框架。<br>受力特征：洞口开得比联肢剪力墙更宽，墙肢宽度较小，墙肢与连梁刚度接近时，墙肢明显出现局部弯矩，在许多楼层有反弯点。剪力墙的内力分布接近框架。壁式框架实质是介于剪力墙和框架之间的一种过渡形式，它的变形已很接近剪切型。只不过壁柱和壁梁都较宽，因而在梁柱交接区形成不产生变形的刚域。</li></ol><h1 id="框架剪力墙结构内力计算"><a href="#框架剪力墙结构内力计算" class="headerlink" title="框架剪力墙结构内力计算"></a>框架剪力墙结构内力计算</h1><p>🖋️核心思路：将所有框架合并为总框架，所有剪力墙合并为总剪力墙，外力在框架和剪力墙之间的分配由协同工作计算确定，协同工作计算采用连续连杆法。<br>PS: 后面《钢结构设计》中框架支撑体系的计算也是如此思路，只是把剪力墙换为支撑。</p><div class="row">    <embed src="框架剪力墙结构内力计算.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="双向板计算"><a href="#双向板计算" class="headerlink" title="双向板计算"></a>双向板计算</h1><p>对于双向板的设计，有<strong>弹性设计</strong>和<strong>塑性设计</strong>两种。对于弹性设计，是通过查表得出弯矩设计值，书上也容易理解。对于塑性设计，书上采用了<strong>塑性铰线法</strong>，通过一系列推到，得到荷载P作用时，板的弯矩（书上表述为<strong>承载力</strong>，尚有不妥，应该为<strong>内力</strong>更好），然后配筋设计了。</p><div align="center"><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/双向板塑性设计.jpg" width="80%"></div><div align="center"><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/双向板塑性设计计算公式.jpg" width="80%"></div><p>从中也可以发现，所谓弹性设计、塑性设计，归纳起来就是<strong>以何种状态的抗力去抵抗该状态下的效应就是何种设计。</strong></p><p><strong>何为单向板与双向板？</strong><br>在学习《混凝土结构基本原理》之初，对于单向板，我们是按照长边/短边大于2（具体分为大于等于3和介于2-3之间）的原则来判断的。久而久之容易形成刻板印象，只通过边长比值来判断，这是不可取的。（见《混凝土》下册P30）<br>而实际上单向板和双向板定义：只在一个方向弯曲或主要在一个方向弯曲的板称为单向板；在两个方向弯曲且不能忽略任一方向弯曲的板称为双向板。</p><h1 id="应力应变、内力与位移之间关系"><a href="#应力应变、内力与位移之间关系" class="headerlink" title="应力应变、内力与位移之间关系"></a>应力应变、内力与位移之间关系</h1><p><strong>应力与应变之间关系</strong>：<br>有应力不一定有应变（这个命题本身不是很严谨）比如三个方向应力取值得当可以使得某一方向无应变。<br>有应变不一定有应力，比如静定结构由于温度差异产生的应变。<br><strong>内力和位移之间联系</strong>：<br>有内力不一定有位移。比如超静定结构中，由于温度变形受到限制而产生内力，但无位移。<br>有位移不一定有内力。比如静定结构支座位移并不产生内力。<br>关于<strong>位移和变形</strong>的区别，可以参考如下：</p><div align="center"><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/位移、变形的区别.png" width="70%"></div><h1 id="结构设计理论发展"><a href="#结构设计理论发展" class="headerlink" title="结构设计理论发展"></a>结构设计理论发展</h1><p>认识、梳理工程结构设计理论的发展历史与发展状况 ，需要从两个基本维度加以考察：</p><ul><li>对结构受力力学行为的科学反映方式；</li><li>对工程中客观存在的不确定性的科学度量方式；</li></ul><h2 id="第一代结构设计理论"><a href="#第一代结构设计理论" class="headerlink" title="第一代结构设计理论"></a>第一代结构设计理论</h2><script type="math/tex; mode=display">\sigma  \le \left[ \sigma  \right]</script><p>式中$[ \sigma ]$为允许应力或容许应力强度，按下式计算：</p><script type="math/tex; mode=display">\left[ \sigma  \right] = \frac{R}{K}</script><p>式中，R为材料强度，K为结构安全系数。</p><h2 id="第二代结构设计理论"><a href="#第二代结构设计理论" class="headerlink" title="第二代结构设计理论"></a>第二代结构设计理论</h2><p>由于Cornell、Ang、Lind等人的杰出工作，基于低阶统计矩的一次二阶矩理论开始完善，并被十分精彩地表达为分项系数设计公式（以结构恒载与活载组合为例)：</p><script type="math/tex; mode=display">{\gamma _R}R \ge {\gamma _G}G + {\gamma _Q}Q</script><p>我国规范中表述的一般形式如下：</p><script type="math/tex; mode=display">\frac{R}{ { {\gamma _R}}} \ge {\gamma _S}S</script><p>由于低阶矩仅能反映荷载与结构抗力分布的主要特征，作为设计衡量标准的可靠度指标β与失效概率之间的关系又基于正态分布假定，因此，人们将这一设计理论称为考虑多种极限状态的<strong>近似概率设计法</strong>（亦称近似概率极限状态设计方法），它构成了第二代结构设计理论的核心。</p><h2 id="第三代结构设计理论"><a href="#第三代结构设计理论" class="headerlink" title="第三代结构设计理论"></a>第三代结构设计理论</h2><p>第二代结构设计理论存在两个基本矛盾：</p><ul><li>在构件设计层次考虑非线性、而在结构分析层次忽略非线性；</li><li>在构件设计层次考虑随机性、而在结构分析层次不承认随机性影响。</li></ul><p>第三代结构设计理论致力于解决上述问题，其基本框架为：<br><img src="/2023/Study/Civil%20engineering/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/第三代结构设计理论框架.jpg" alt="第三代结构设计理论框架"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 李杰. 论第三代结构设计理论[J]. 同济大学学报(自然科学版), 2017, 45(5): 617-624+632.</p>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构设计杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力学基础和专业基础(持续更新)</title>
      <link href="/2023/Study/Civil%20engineering/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/Study/Civil%20engineering/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="材料力学"><a href="#材料力学" class="headerlink" title="材料力学"></a>材料力学</h2><ol><li>最近学了拉压、扭的部分，大致思路都是<strong>强度-刚度-应变能</strong>，公式也很类似。下面分享几个比较有意思的点：<br>第一个是<strong>小变形放大图</strong>，常用来解决超静定问题，依靠<strong>平衡方程</strong>和<strong>变形协调方程</strong>，再加上本构方程。这里的<strong>变形协调</strong>其实就是后面<strong>力法方程的本质</strong>，可以说是埋下伏笔了。</li><li>第二个是<strong>功互等定理</strong>和<strong>位移互等定理</strong>，在材料力学中只是当作附加部分讲了讲，并没有涉及其本质，具体推导可以参见 <strong>《结构力学》（龙驭球）第五章最后一节</strong>，用虚功原理予以解释，此外，那里还介绍了两个互等定理。注意：上述四个互等定理只适用于<strong>线性变形体系</strong>。 </li><li><strong>剪应力互等定理</strong>新的理解<br> 详细可以参考一下这篇文章。感觉与以前理解不同的地方在于：取出来的单元体实际上六个面均有力，每个面有两个方向的切应力和一个正应力，相对的面上应力相等。（他给出的解释是单元体足够小，可以看作一个点，故相对的两个面力相等） <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.zhihu.com<span class="regexp">/question/</span><span class="number">21070058</span></span><br></pre></td></tr></table></figure></li><li>非对称纯弯曲梁的正应力（《材料力学》下册1-1节）<br>推导得到了<strong>广义弯曲正应力</strong>，有一个印象即可。对于<strong>非对称弯曲</strong>，应该是指梁不具有对称平面，或者梁具有对称平面，但外力不作用在该平面内，梁将发生非对称弯曲。</li><li><p>开口薄壁截面梁的剪应力流和弯曲中心<br><strong>截面剪应力流的方向确定</strong>：(简单的根据：与剪力平行的截面上剪应力流与剪力平行，例如矩形截面，工字形截面的腹板等。)</p><ol><li>根据截面弯矩和中性轴确定拉压应力；(方便下一步由正应力合成轴力)</li><li>切开构件，取隔离体，根据隔离体轴力平衡，非自由面取切应力(一般只有3个非自由面，其中有两个是前后轴力方向，另一个面取剪应力来平衡)，然后再根据剪应力互等定理确定前后两个非自由面上剪应力方向。</li></ol><div class="row">    <embed src="弯曲中心.pdf" width="100%" height="550" type="application/pdf"></div><p>而弯曲中心的确定方法见《材料力学合并文档》P252.核心就是<strong>截面上剪应力合成到某点，只有力而无力偶，该点即为弯曲中心</strong>。<br>重点是<strong>弯曲中心（剪切中心）的作用</strong>：非对称截面梁发生平面弯曲的条件：<strong>外力必须作用在通过弯曲中心且平行于形心主惯性平面（或与之重合）的平面内。</strong></p></li></ol><h2 id="结构力学"><a href="#结构力学" class="headerlink" title="结构力学"></a>结构力学</h2><h3 id="单自由度结构自由振动自振频率的求解"><a href="#单自由度结构自由振动自振频率的求解" class="headerlink" title="单自由度结构自由振动自振频率的求解"></a>单自由度结构自由振动自振频率的求解</h3><p>今天复习了结构动力学基础中一个重要问题——单自由度结构体系自由振动自振频率的求解。困扰了将近一年的问题今天终于搞定了。顺便复习了<strong>科氏加速度</strong>等几个概念，具体参见《理论力学》P190.<br><div class="row">    <embed src="单自由度结构体系自振频率求解.pdf" width="100%" height="550" type="application/pdf"></div></p><h3 id="虚功原理、虚力原理与虚位移原理辨析"><a href="#虚功原理、虚力原理与虚位移原理辨析" class="headerlink" title="虚功原理、虚力原理与虚位移原理辨析"></a>虚功原理、虚力原理与虚位移原理辨析</h3><div class="row">    <embed src="虚功原理、虚力原理与虚位移原理.pdf" width="100%" height="550" type="application/pdf"></div><p>根据上述资料，可知虚功原理表述为：<br>如果<strong>力系满足平衡方程，变形状态满足协调方程</strong>，则虚功方程（下式）成立。</p><script type="math/tex; mode=display">\begin{equation*} \sum F _ { P } \Delta + \sum F _ { R K } C _ { K } = \sum \int _ { A } ^ { B } ( Mk+ F _ { N } \varepsilon + F _ { Q } \gamma _ { 0 } ) d s\end{equation*}</script><p><strong>然后，单独一个虚功方程只是必要条件，而不是充分条件。</strong><br>由此引出一个想法：能否将虚功原理及其虚功方程(上式)加以改造，使改造后的“虚功型方程”（指：用虚功形式表示的方程）成为变形协调方程或力系平衡方程的充分必要条件呢？于是，就产生了下列两个“虚功型原理”一虚力原理和虚位移原理。</p><p><strong>虚力原理</strong>：<br><strong>在虚设力系满足平衡方程且具有任意性的前提下</strong>，如果虚力方程（下图）成立，则待检查的变形状态必满足变形协调方程。反之，在上述前提下，如果已知该变形状态满足变形协调方程，则虚力方程必成立。综合起来，在上述前提下，虚力方程是变形协调方程的充分必要条件。</p><div align="center"><img src="/2023/Study/Civil%20engineering/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚力方程.jpg" width="70%"></div><p><strong>虚位移原理</strong>：<br><strong>在虚设变形状态满足变形协调方程并具有任意性的前提下</strong>，如果虚位移方程(下式)成立，则待检查的力系必满足平衡方程。反之，在上述前提下，如果已知该力系满足平衡方程，则虚位移方程必成立。综合起来，在上述前提下，虚位移方程是力系平衡方程的充分必要条件。</p><div align="center"><img src="/2023/Study/Civil%20engineering/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚位移方程.jpg" width="70%"></div><h3 id="结构对称性探究"><a href="#结构对称性探究" class="headerlink" title="结构对称性探究"></a>结构对称性探究</h3><div class="row">    <embed src="结构对称性探究.pdf" width="100%" height="550" type="application/pdf"></div><p>正是由于上述结论，可将奇/偶跨对称结构简化，<strong>简化的要求是与原结构等效，表现为力和变形条件。</strong><br>值得注意的是，<strong>对称轴处的荷载要减半，当然最终结果加和时，对称轴处相当于加了两次，合理的。</strong> 可参考下面这两篇文章：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章一：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">576399081</span></span><br><span class="line">文章二：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">147244195</span></span><br></pre></td></tr></table></figure></p><h4 id="对称边界与反对称边界位移条件"><a href="#对称边界与反对称边界位移条件" class="headerlink" title="对称边界与反对称边界位移条件"></a>对称边界与反对称边界位移条件</h4><p>最近学习了<strong>水哥ansys初级教程</strong>，其中谈到<strong>对称边界和反对称边界位移条件时</strong>时，有：</p><ol><li>受对称载荷作用则对称面上的位移条件为<ol><li>垂直于对称面的移动位移分量为零。</li><li>绕平行于对称面的两相互垂直的轴的转动位移分量均为零。</li></ol></li><li>受反对称载荷作用则对称面上的位移条件为<ol><li>平行于对称面的移动位移分量为零；</li><li>绕方向矢量垂直于对称面的轴的转动位移分量为零。</li></ol></li></ol><h3 id="结构平衡-几何矩阵互伴定理"><a href="#结构平衡-几何矩阵互伴定理" class="headerlink" title="结构平衡-几何矩阵互伴定理"></a>结构平衡-几何矩阵互伴定理</h3><p>定理证明：</p><ul><li>龙驭球《结构力学》下册 第14章</li></ul><p>定理的运用，以老师留的习题为例：<br><div class="row">    <embed src="结构平衡-几何矩阵互伴定理.pdf" width="100%" height="550" type="application/pdf"></div></p><hr><p>上述资料是按照矩阵分析一步步来的，略显繁琐，谭启阳老师讲了另一种方法，如下面这个所示，关键就是<strong>力系平衡和变形协调</strong>！<br><div class="row">    <embed src="结构平衡-几何矩阵互伴定理(老师解答).pdf" width="100%" height="550" type="application/pdf"></div></p><p>其实，通过结构平衡-几何矩阵互伴定理可以推出结构刚度矩阵正定的，这里我以上述题目为例，验证如下：<br>已知：</p><script type="math/tex; mode=display">Af = F</script><script type="math/tex; mode=display">BX = \Delta</script><p>且</p><script type="math/tex; mode=display">A = {B^T}</script><p>证明：<br>现设矩阵C如下：<br>$$C = \left[ {\begin{array}{*{20}{c}}{\frac{{EA}}{{{l_1}}}}&0&0\\0&{\frac{{EA}}{{{l_2}}}}&0\\0&0&{\frac{{EA}}{{{l_3}}}}\end{array}} \right]$$</p><p>将方程$BX = \Delta$左右两端同左乘C，则有：</p><script type="math/tex; mode=display">CBX = C\Delta</script><p>又根据$C\Delta  = f$，则有：</p><script type="math/tex; mode=display">BCX = f</script><p>方程两边再同左乘$A$，则有：</p><script type="math/tex; mode=display">ACBX = Af = F</script><p>由于$A = {B^T}$，推出：</p><script type="math/tex; mode=display">{B^T}CBX = F</script><p>显然，刚度矩阵$K = {B^T}CB$，现令$C = {D^T}D$，$Q = DB$，则刚度矩阵转化为：</p><script type="math/tex; mode=display">K = {Q^T}Q</script><p>由于$Q$是可逆矩阵，根据线性代数知识知，$K$必为正定矩阵。<br>得证！ </p><h3 id="结构刚度矩阵推导的两种方法"><a href="#结构刚度矩阵推导的两种方法" class="headerlink" title="结构刚度矩阵推导的两种方法"></a>结构刚度矩阵推导的两种方法</h3><div class="row">    <embed src="结构刚度矩阵推导的两种方法.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="分层法迭代过程"><a href="#分层法迭代过程" class="headerlink" title="分层法迭代过程"></a>分层法迭代过程</h3><div class="row">    <embed src="分层法迭代过程.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="土力学"><a href="#土力学" class="headerlink" title="土力学"></a>土力学</h2><p>由于较少从事这方面研究，目前待更新！！！</p><h2 id="混凝土结构基本原理"><a href="#混凝土结构基本原理" class="headerlink" title="混凝土结构基本原理"></a>混凝土结构基本原理</h2><h3 id="钢筋混凝土受扭构件承载力公式推导的两种方法"><a href="#钢筋混凝土受扭构件承载力公式推导的两种方法" class="headerlink" title="钢筋混凝土受扭构件承载力公式推导的两种方法"></a>钢筋混凝土受扭构件承载力公式推导的两种方法</h3><p>此文章写于大三下学期，目前来看，这两种方法的本质相同，第一种根据q相同求得，第二种根据Tu相同求得，但又有 </p><script type="math/tex; mode=display">\begin{equation*} T_{u} = 2qA_{cor}\end{equation*}</script><p>故其本质相同。<br><div class="row">    <embed src="钢筋混凝土受扭构件承载力.pdf" width="100%" height="550" type="application/pdf"></div></p><h2 id="钢结构基本原理"><a href="#钢结构基本原理" class="headerlink" title="钢结构基本原理"></a>钢结构基本原理</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><h4 id="轴心受压、受弯及压弯构件的宽厚比限值"><a href="#轴心受压、受弯及压弯构件的宽厚比限值" class="headerlink" title="轴心受压、受弯及压弯构件的宽厚比限值"></a>轴心受压、受弯及压弯构件的宽厚比限值</h4><p>宽厚比限值的根本目的是为了防止局部失稳先于整体失稳。由此，规范采用等稳定性原则，即板件屈曲应力不小于构件屈曲应力。</p><script type="math/tex; mode=display">\begin{equation*} \sigma_{crx}\geq \sigma _{cr}\end{equation*}</script><p>同时，根据<strong>以何种状态下（例如弹性）抗力抵抗该种状态下效应即为该种状态设计</strong>，故当板件弹性屈曲应力不小于构件弹性屈曲应力，为<strong>弹性设计</strong>。</p><script type="math/tex; mode=display">\begin{equation*} \frac{b_{1}}{t}\leq 15 \varepsilon _{k}\end{equation*}</script><p>这些天(2023-10-17)恰好在学习冷弯薄壁型钢的设计，这里举例如下：</p><div align="center"><img src="/2023/Study/Civil%20engineering/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/冷弯薄壁型钢整体屈曲与局部屈曲关系.jpg" width="70%"></div><h2 id="土木工程施工"><a href="#土木工程施工" class="headerlink" title="土木工程施工"></a>土木工程施工</h2><h3 id="土方工程"><a href="#土方工程" class="headerlink" title="土方工程"></a>土方工程</h3><h4 id="基坑支护"><a href="#基坑支护" class="headerlink" title="基坑支护"></a>基坑支护</h4><p>基坑支护包括一般基坑支护和深基坑支护。<br>深基坑支护方法有：</p><ol><li><strong>水泥土挡墙式支护结构</strong>：采用深层搅拌机就地将土和输入的水泥浆强行搅拌，形成连续搭接的水泥土柱状加固体挡墙。</li><li><strong>排桩与板墙式支护结构</strong>：开挖前在基坑周围设置砼灌注桩或钢板桩，桩的排列有间隔式、双排式和连续式，桩顶设置砼连系梁或锚桩、拉杆。</li><li><strong>土钉墙支护</strong>：在天然土体通过钻孔、插筋、注浆来设置土钉(亦称砂浆锚杆)并与喷射砼面板相结合，形成类似重力挡墙的土钉墙，以抵抗墙后的土压力，保持开挖面的稳定。</li><li><strong>土层锚杆支护结构</strong>：在深基础立壁上钻孔，并达到一定深度，然后在孔内放入钢筋等材料，灌入泥浆或化学浆液，使其与土层结合成为抗拉（拔）力强的锚杆，将立壁土体侧压力传至稳定土层。<blockquote><p>在实际工程中，其实上述某些方法可组合使用，例如挡土灌注桩（排桩）+土层锚杆等。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力学基础与专业基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学生活</title>
      <link href="/2023/Life/%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B4%BB/"/>
      <url>/2023/Life/%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9267441ee97e708844a7bd43dec29be36547efb548936ab43d2e935e8a5a664d">d92edc86f96c364344662e88ccfd178a6e94a7b3b44d36a013234e28c079f5cd7469b4cd68d11cba998b535f3291c11ff7413f9f9d4d08e0e38744a124c8311236befc7dbc8aac945232a9a2c9edae954a80a20287fc96ececda1f4e7068af8bb9b004a75aa4e379c7af448fa33b7e2d039ef04acf56f52b58717d6b69616479442236664e3001943cb7b7c0a71effb00467030071fb9e0803066418703628d4db5d66af0728e54bab54ce355f9952c1752f7fe7c01181d2b31e64fb05c9bf74636d7862e449d66485b94dcf952babb113dd57a8a9b639a9e44905e76f1860a7c25a21d3108c48968bc6c5cce6886f10896a8ba458b8cfe79c19011c8f301c713117fc7e867a41c1f76db7332a82d780cee588696029826b4c44894bef802e0b598d252d868c596fa71a2d3f773edb6099b597d7d0e1a47e9cb312cd4fd9a4585379db7dddb5d7b613c52aefe7886faf106c2b62caef2a06a17a20bcdec7848abbb407a2b9bd29d2dd726488ae170eed1717c7d02df68d5de4db7adcf2056076ff0e7f945cd30f728dd3ab25ed4855c9943704d49f5460e5e842fdad6e6a984cdd6f178119762504043f9a08fa67dc0e6a26697b5b5a2d5ba40bd52f578633db8cecd0ff4d95e07103bfa6dc73d1b2674e93f0807c7e529051b590714eb949b088b24dc7d553647fc8b420cf5e223ada16f548d69db73002530a1903396126d5d320c37e3a9f47467ab70795d969b6325553af0675892a5560afa4c3a670fc4b107ac4d815b911940dec667d8fb77dfce6b43a74764115d71d3479c0212828bc4560090422d36814c77560a50170e853abb4fe921d8a850ccb8b3e8e894812dbf1ca2a875bfce6c79af0778efd6c52e20f7858df5ef09663ee234fd7a82690b3987c6141a89bb81f5ad4e3d21d95363e30fa85f20a4ffe7cb18571da3234a5fe18bcd66947b593ead85e9f5f5ed4d181a58f55cde78d067a71fef062539122be3ff59267d04bd37757b20b309467dc56c0030827a4da687161fedcfe0a1b2ae0c62e09ca0d63eca446335b40ebcafce3edddd6523504054f1e3f574e3951754917b21c56eb8ab8723d94dd7321ba9a562a3e16507998681d51287c3d2e4f2574d514f3f93da52be74f3d786e97837771c8cc7aa5e3d6e5298051228cad465e07cd730c2b39a6d7193fb773b4856fdd934530504970fcce8a06b5cc5c38e0facbf36a6e0c6f0363aaff669224df912ac50c3d04c5808e2bb59b3a1d57bd5648aa284d1dff062a579c764f7e81c3bd499bd49272c5abb5dec434c505b3ae712c13cb5962f5d1ea1afbfcea82a52ebe2319637527fa5ec25641b2327bdc4e306f7963beb9f7115e12603800770d99af05c414b7cf1a46e5052eb704cc29de122960e6c96db8ddebc5a942740892cd02abbdc9c68930c191b121c343d47d3e85fe429f483519256daf1ba29d8f6e55ed13c7c356975c07451be9207eec9fee637d7ce100b82896b1e910f2599f5b37ab2fc6305e70b673f117f089fac1bea1639c392f27731ff8349ac85f436e7ec08bae80abd19ac81ea69ba8f010de1aa26bc33c62cde4b2a16c76334538b72db116a0ab5df19e263c046824ce802f7d4a330e8e71f614b2c2e115428eb93029f9d82e02a8d44726d179fb81604e0b81856542d1f9e00329146258ade69185820a4a7feeecfed5be660ca77ac5d896fd128514bb2474f4bc15b6f4d1f1e2757d8578364884748a56f0eb3e8afc4ff5e1c5629ec401b6fc6946255675c3106c897fdfe4a2b52b3cbca9c72c88b8736e016ad3b09142e3cdbff3f90a597c9ca5b1e5f6ac6b39a49d00cddf07f0bdf41059592a5e3dd6301b4384a23e01db189f269fe8a4bd0a89dbf3c8321ff786c74397ae1c3c49dd9c4fd90184bfd8c892bcdbdf8532f6603d4e364a761d83373070330a61833687d82eaadd6f60dc8802f7dc8b13c98493ca0469de7b3520768835a37c1d988d36d9f71675d741c6c045ecac4284eedc8eae28150e7d76539bef605da1e9f17de6ab4e48910c1ba6e56598bd12fbc95b51f1e84ddfb6cfbd068cf9f73cbab9428b33be7be8a1a0f522ce547042e20afe1e9328d8081f323547fb5d8ab981b9811747a34101beb886b7850ce4ffa50757b5ff664f26447997383a0587362544b81cf97b0b1c54663b97a8c956bf25617dfc8808149a2df0ca2d5980b4d2cc244217a79e92a0ee24962e4ffb9467c99a062e0de4b66e3a2d9c7be2f79c5211de23a241c9ff384ddd07d85bf7cb794b1c4d0d4a62fcc6ed2ec107b0d6f786a67e714733b84fb80bba9503c3dd7c8ede96c6a01add49914a3fdb842f6234ec6dc63b66e472c2915cda7c9308659107548a922ccc70edce78a449b8d4cbea4e7d5f9366464a858cb21d78dd4e769b97922562edf6aed81cc56f4c3e12dceebbf99e91c56c7741f71039c61d9ed9a942ae10d0ff15fd8f8ea14e5da0f354a38249b3139b622b5d9c421c2a51e1bb8fccdf0fa4c9e31372b8dbd2d3c84d9e8f6ef9b5a73d5b9e591755bf36188ce929b3969a0542272477944764c64a77f28d9633c6e5dd4ce8f7908dc8c8a866074e81ffa4b0cacf68b5db1da9b6708e668caa47a1c1ac0c161e0317f92200687fb2871b9ecee99095e2cfbf00d5190720bd3af61ed9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
